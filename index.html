9<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Panel and Parts Configuration</title>
  <style>
    /* Full CSS */
    :root {
      --primary-color: #003366;
      --secondary-color: #0099CC;
      --accent-color: #FF6600;
      --background-color: #F5F5F5;
      --text-color: #333333;
      --button-gradient: linear-gradient(135deg, #0099CC, #003366);
      --button-hover-gradient: linear-gradient(135deg, #0077B3, #002244);
      --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --shadow-hover: 0 6px 12px rgba(0, 0, 0, 0.2);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--background-color);
      color: var(--text-color);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      width: 100%;
      min-width: 120px;
      background-color: white;
      border-radius: 30px;
      box-shadow: var(--shadow);
      overflow: auto;
      height: 6000px;
    }

    .tab-buttons {
      display: flex;
      gap: 10px;
      padding: 20px;
      background-color: var(--primary-color);
      border-radius: 12px 12px 0 0;
    }

    .tab-buttons button {
      padding: 10px 20px;
      background: var(--button-gradient);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      box-shadow: var(--shadow);
    }

    .tab-buttons button:hover {
      background: var(--button-hover-gradient);
      box-shadow: var(--shadow-hover);
      transform: translateY(-2px);
    }

    .tab-buttons button.active {
      background: var(--accent-color);
    }

    .tab {
      display: none;
      padding: 20px;
    }

    .tab.active {
      display: flex;
      gap: 20px;
    }

    .sidebar {
      width: 250px;
      background-color: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: var(--shadow);
    }

    .sidebar button {
      width: 100%;
      padding: 10px;
      margin: 10px 0;
      background: var(--button-gradient);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      box-shadow: var(--shadow);
    }

    .sidebar button:hover {
      background: var(--button-hover-gradient);
      box-shadow: var(--shadow-hover);
      transform: translateY(-2px);
    }

    .panel-container {
  flex:2;
  background-color: black;
  border-radius: 12px;
  box-shadow: var(--shadow);
  position: relative;
  overflow: 2000px;
  height: 2000px;
}

   
    .rail-graphic {
      position: absolute;
      background-color: var(--secondary-color);
      height: 18px;
      padding: 20px;
      width: 324px;
      border-radius: 4px;
      z-index: 1;
    }

    .part {
      position: absolute;
      padding: -10px;
      background-color: var(--accent-color);
      border: none;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 10px;
      text-align: center;
      flex-direction: column;
      z-index: 2;
      box-shadow: var(--shadow);
      transition: all 0.3s ease;
      cursor: grab;
    }

    .part .dots {
      display: flex;
      gap: 10px;
      position: absolute;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
    }

    .part .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: 1px solid black;
    }

    .part .data-indicator {
      position: absolute;
      top: 5px;
      left: 5px;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background-color: red;
    }

    .part .data-indicator.green {
      background-color: green;
    }

    .part .arrows {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      pointer-events: none;
    }

    .part .arrows button {
      pointer-events: all;
      background: rgba(255, 255, 255, 0.8);
      border: none;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: var(--shadow);
    }

    .part .arrows button:hover {
      background: white;
    }

    .wiring-svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: all;
    }

    .wiring-svg path {
      stroke-width: 6;
      fill: none;
    }

    .wire-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: var(--shadow);
      z-index: 1000;
    }

    .wire-popup button {
      width: 100%;
      padding: 10px;
      margin: 10px 0;
      background: var(--button-gradient);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      box-shadow: var(--shadow);
    }

    .wire-popup button:hover {
      background: var(--button-hover-gradient);
      box-shadow: var(--shadow-hover);
      transform: translateY(-2px);
    }

    .space-layout,
    .load-schedule {
      padding: 20px;
    }

    .space-layout h2,
    .load-schedule h2 {
      margin-bottom: 20px;
    }

    .space-layout table,
    .load-schedule table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }

    .space-layout th,
    .space-layout td,
    .load-schedule th,
    .load-schedule td {
      padding: 10px;
      border: 1px solid #ddd;
      text-align: left;
    }

    .space-layout th,
    .load-schedule th {
      background-color: var(--primary-color);
      color: white;
    }

    .space-layout tr:nth-child(even),
    .load-schedule tr:nth-child(even) {
      background-color: #f9f9f9;
    }

    .space-layout input[type="text"],
    .space-layout input[type="number"] {
      width: 100%;
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .nested-table {
      width: 100%;
      border-collapse: collapse;
    }

    .nested-table td {
      padding: 5px;
      border: 1px solid #ddd;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Tab Buttons -->
    <div class="tab-buttons">
      <button id="main-tab-button" class="active">Main Page</button>
      <button id="wiring-tab-button">Panel Wiring</button>
      <button id="space-tab-button">Space Layout</button>
      <button id="load-tab-button">Load Schedule</button>
      <button id="print-pdf-button">Print to PDF</button>
    </div>

    <!-- Main Page Tab -->
    <div id="main-tab" class="tab active">
      <div class="sidebar">
        <label for="panel-select">Panel Selection:</label>
        <select id="panel-select">
          <option value="DIN-EN-2X18">DIN-EN-2X18</option>
          <option value="DIN-EN-3X18">DIN-EN-3X18</option>
          <option value="DIN-EN-6X18">DIN-EN-6X18</option>
          <option value="DIN-EN-10X18">DIN-EN-10X18</option>
        </select>
        <button data-part="ZUMNET-DIN-DLI">Add ZUMNET-DIN-DLI</button>
        <button data-part="ZUMNET-DIN-16A-LV">Add ZUMNET-DIN-16A-LV</button>
        <button data-part="ZUMLINK-DIN-PSU">Add ZUMLINK-DIN-PSU</button>
        <button data-part="ZUMLINK-DIN-IO">Add ZUMLINK-DIN-IO</button>
        <button data-part="ZUM-HUB4">Add ZUM-HUB4</button>
        <button data-part="CEN-SWPOE-5AC">Add CEN-SWPOE-5AC</button>
        <button data-part="ZUMLINK-DIN-16A-LV">Add ZUMLINK-DIN-16A-LV</button>
        <button data-part="ZUMLINK-DIN-20A-SW">Add ZUMLINK-DIN-20A-SW</button>
        <button data-part="ZUMLINK-DIN-20A-PLUG">Add ZUMLINK-DIN-20A-PLUG</button>
        <button data-part="ZUMLINK-DIN-DIMU">Add ZUMLINK-DIN-DIMU</button>
        <button data-part="DIN-DMX">Add DIN-DMX</button>
        <button data-part="DIN-AP4">Add DIN-AP4</button>
        <button data-part="DIN-PWS60">Add DIN-PWS60</button>
        <button data-part="DIN-DALI-2">Add DIN-DALI-2</button>
      </div>
      <div class="panel-container" id="panel-container">
        <div class="panel" id="panel"></div>
      </div>
    </div>

    <!-- Panel Wiring Tab -->
    <div id="wiring-tab" class="tab">
      <div class="sidebar">
        <button id="generate-panel">Generate Panel</button>
        <button id="draw-wiring">Draw Wiring</button>
        <button id="clear-wiring">Clear All Wiring</button>
      </div>
      <div class="panel-container">
        <div id="wiring-panel" class="panel"></div>
        <svg class="wiring-svg" id="wiring-svg"></svg>
      </div>
    </div>

    <!-- Space Layout Tab -->
    <div id="space-tab" class="tab">
      <div class="space-layout">
        <h2>Space Layout</h2>
        <table id="space-table">
          <thead>
            <tr>
              <th>Space Name</th>
              <th>Load Controller</th>
              <th>mA Draw</th>
              <th>Device mA</th>
              <th>Total Power Draw</th>
            </tr>
          </thead>
          <tbody>
            <!-- Rows will be dynamically added here -->
          </tbody>
        </table>
      </div>
    </div>

    <!-- Load Schedule Tab -->
    <div id="load-tab" class="tab">
      <div class="load-schedule">
        <h2>Load Schedule</h2>
        <table id="load-table">
          <thead>
            <tr>
              <th>Space Name</th>
              <th>Circuit #</th>
              <th>Zone</th>
              <th>Load Controller</th>
              <th>Lighting Load</th>
              <th>Circuit Load Total</th>
            </tr>
          </thead>
          <tbody>
            <!-- Rows will be dynamically added here -->
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Part Information Popup -->
  <div id="part-popup" class="wire-popup" style="display: none;">
    <h3>Part Information</h3>
    <form id="part-form">
      <label for="space-name">Space Name*:</label>
      <input type="text" id="space-name" required>
      <label for="circuit-number">Circuit #:</label>
      <input type="text" id="circuit-number">
      <label for="zone">Zone:</label>
      <input type="text" id="zone">
      <label for="lighting-load">Lighting Load (watts):</label>
      <input type="number" id="lighting-load">
      <label for="device-ma">Device mA:</label>
      <input type="number" id="device-ma">
      <button type="submit">Save</button>
    </form>
  </div>

  <!-- Wire Selection Popup -->
  <div id="wire-popup" class="wire-popup" style="display: none;">
    <h3>Select Wire Type</h3>
    <button data-type="CRESNET">CRESNET (Green)</button>
    <button data-type="ETHERNET">ETHERNET (Blue)</button>
    <button data-type="ZUMNET">ZUMNET (Purple)</button>
    <button data-type="ZUMLINK">ZUMLINK (Orange)</button>
    <button data-type="POWER">POWER (Black)</button>
    <button data-type="DMX">DMX (Rainbow Dotted)</button>
  </div>
<div class="element"></div>
  <!-- Add the html2canvas and jsPDF libraries -->
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
    const { jsPDF } = window.jspdf;

document.getElementById('print-pdf-button').addEventListener('click', async () => {
  const pdf = new jsPDF('p', 'pt', [1242, 792]); // 11x17 inches in points (1 inch = 72 points)
  const tabs = ['main-tab', 'wiring-tab', 'space-tab', 'load-tab'];
  const scale = 1.5; // Adjust the scale as needed

  for (let i = 0; i < tabs.length; i++) {
    const tab = document.getElementById(tabs[i]);
    if (!tab) continue; // Skip if the tab doesn't exist

    try {
      // Ensure the tab is visible before capturing
      tab.style.display = 'flex'; // Or 'block', depending on your CSS
      await new Promise((resolve) => setTimeout(resolve, 100)); // Wait for rendering

      // Capture the tab as an image
      const canvas = await html2canvas(tab, { 
        scale: scale,
        useCORS: true, // Enable cross-origin images
        logging: true, // Enable logging for debugging
        scrollX: -window.scrollX, // Capture the entire width
        scrollY: -window.scrollY, // Capture the entire height
        windowWidth: tab.scrollWidth, // Use the full width of the tab
        windowHeight: tab.scrollHeight, // Use the full height of the tab
      });

      // Convert the canvas to a data URL
      const imgData = canvas.toDataURL('image/png', 1);

      // Get the dimensions of the PDF page
      const pdfWidth = pdf.internal.pageSize.getWidth();
      const pdfHeight = pdf.internal.pageSize.getHeight();

      // Calculate the aspect ratio of the captured image
      const imgProps = pdf.getImageProperties(imgData);
      const imgAspectRatio = imgProps.width / imgProps.height;

      // Calculate the maximum dimensions to fit within the PDF page
      let imgWidth = pdfWidth; // Default to full width
      let imgHeight = pdfWidth / imgAspectRatio; // Adjust height based on aspect ratio

      // If the calculated height exceeds the PDF page height, adjust dimensions
      if (imgHeight > pdfHeight) {
        imgHeight = pdfHeight;
        imgWidth = pdfHeight * imgAspectRatio;
      }

      // Add a new page for each tab (except the first one)
      if (i > 0) {
        pdf.addPage();
      }

      // Add the image to the PDF, centered on the page
      const x = (pdfWidth - imgWidth) / 2; // Center horizontally
      const y = (pdfHeight - imgHeight) / 2; // Center vertically
      pdf.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight, undefined, 'FAST');

      // Hide the tab after capturing (optional)
      tab.style.display = 'none';
    } catch (error) {
      console.error('Error capturing tab:', tabs[i], error);
    }
  }

  // Save the PDF
  pdf.save('panel-configuration.pdf');

  // Restore the visibility of all tabs after PDF generation
  tabs.forEach((tabId) => {
    const tab = document.getElementById(tabId);
    if (tab) tab.style.display = 'flex'; // Or 'block', depending on your CSS
  });
});
function calculateRailDistance() {
  if (railPositions.length < 2) {
    console.error('Not enough rails to calculate distance.');
    return 0;
  }

  const firstRailTop = railPositions[0]; // Top position of the first rail
  const lastRailTop = railPositions[railPositions.length - 1]; // Top position of the last rail

  const distance = lastRailTop - firstRailTop; // Calculate distance in pixels
  console.log(`Distance between first and last rail: ${distance}px`);
  return distance;
}
    // Existing JavaScript code remains unchanged
// Main Page Logic
// JavaScript to update the CSS variable
const element = document.querySelector('.element');
const newHeight = '${height}px'; // New height value
document.documentElement.style.setProperty('--dynamic-height', `${newHeight}px`);
const panelSelect = document.getElementById('panel-select');
const panel = document.getElementById('panel');
const parts = {
  'ZUMNET-DIN-DLI': { width: 71, height: 94, color: 'purple', mA: 150, dots: ['purple', 'purple', 'orange', 'orange'] },
  'ZUMNET-DIN-16A-LV': { width: 71, height: 71, color: 'purple', mA: 120, dots: ['purple', 'purple', 'orange', 'orange'] },
  'ZUMLINK-DIN-PSU': { width: 71, height: 71, color: 'orange', mA: 0, dots: ['orange', 'orange', 'orange', 'orange'] }, // Excluded
  'ZUMLINK-DIN-IO': { width: 71, height: 94, color: 'orange', mA: 145, dots: ['orange', 'orange'] },
  'ZUM-HUB4': { width: 165, height: 439, dots: ['green', 'purple', 'purple'] },
  'CEN-SWPOE-5AC': { width: 187, height: 120, dots: ['blue', 'blue', 'blue', 'blue', 'blue'] },
  'ZUMLINK-DIN-16A-LV': { width: 53, height: 94, color: 'orange', mA: 100, dots: ['orange', 'orange'] },
  'ZUMLINK-DIN-20A-SW': { width: 53, height: 94, color: 'orange', mA: 50, dots: ['orange', 'orange'] },
  'ZUMLINK-DIN-20A-PLUG': { width: 53, height: 71, color: 'orange', mA: 50, dots: ['orange', 'orange'] },
  'ZUMLINK-DIN-DIMU': { width: 53, height: 94, color: 'orange', mA: 100, dots: ['orange', 'orange'] },
  'DIN-DMX': { width: 144, height: 90, dots: ['blue', 'black', 'grey', 'grey'] },
  'DIN-AP4': { width: 161, height: 91, dots: ['green', 'green', 'blue'] },
  'DIN-PWS60': { width: 108, height: 94, dots: ['green', 'green', 'green', 'black'] },
  'DIN-DALI-2': { width: 159, height: 95, dots: ['blue', 'green'] },
  'TERMINAL RAIL': { width: 80, height: 50, color: 'multi', dots: [] },
};

const panelSizes = {
  'DIN-EN-2X18': { width: 324, height: 323, rails: 2 }, // Fixed panel and rail width to 324mm
  'DIN-EN-3X18': { width: 324, height: 597, rails: 3 },
  'DIN-EN-6X18': { width: 324, height: 989, rails: 6 },
  'DIN-EN-10X18': { width: 324, height: 1594, rails: 10 },
};

let rails = [];
let currentRailIndex = 0;
let currentXPosition = 0;
let partsData = [];
let spaceCounter = 1;

function initializePanel() {
  const selectedPanel = panelSelect.value;
  const { width, height, rails: railCount } = panelSizes[selectedPanel];
  panel.style.width = `${width}px`; // Set panel width to 324mm
  panel.style.height = `${height}px`;
  panel.innerHTML = '';

  rails = [];
  const railSpacing = (height / (railCount + 1)) * 1.3; // Increase spacing by 30%
  for (let i = 1; i <= railCount; i++) {
    const rail = document.createElement('div');
    rail.className = 'rail-graphic';
    rail.style.top = `${railSpacing * i - 80}px`;
    rail.style.left = '20px'; // Align rails to the left
    panel.appendChild(rail);
    rails.push({ element: rail, parts: [], widthUsed: 0 });
  }

  currentRailIndex = 0;
  currentXPosition = 25; // Start from the left edge
}

function addPart(partType, position = null) {
  const partData = parts[partType];
  if (currentRailIndex >= rails.length) {
    alert('No more rails available in this panel!');
    return;
  }

  // Check if the part will exceed the rail width
  if (rails[currentRailIndex].widthUsed + partData.width > 324) {
    currentRailIndex++; // Move to the next rail
    currentXPosition = 25; // Reset X position
    if (currentRailIndex >= rails.length) {
      alert('No more rails available in this panel!');
      return;
    }
  }

  const part = document.createElement('div');
  part.className = 'part draggable';
  part.style.width = `${partData.width}px`;
  part.style.height = `${partData.height}px`;
  part.textContent = partType;
  part.style.backgroundColor = partData.color || '#4CAF50';

  // Add color dots
  const dotsContainer = document.createElement('div');
  dotsContainer.className = 'dots';
  partData.dots.forEach((dotColor) => {
    const dot = document.createElement('div');
    dot.className = 'dot';
    dot.style.backgroundColor = dotColor;
    dotsContainer.appendChild(dot);
  });
  part.appendChild(dotsContainer);

  // Add data indicator (red/green dot)
  const dataIndicator = document.createElement('div');
  dataIndicator.className = 'data-indicator';
  part.appendChild(dataIndicator);

  // Add double-click to edit
  part.addEventListener('dblclick', () => showPartPopup(partType, part));

  // Add right-click to delete with confirmation popup
  part.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    const confirmDelete = confirm('Are you sure you want to delete this part?');
    if (confirmDelete) {
      part.remove();
      partsData = partsData.filter((p) => p.partElement !== part);
      updateSpaceTable();
      updateLoadSchedule();
    }
  });

  if (position) {
    // Place the part at the specified position
    part.style.left = `${position.left}px`;
    part.style.top = `${position.top}px`;
  } else {
    const rail = rails[currentRailIndex];

    // Position the part
    part.style.left = `${currentXPosition}px`;
    part.style.top = `${parseInt(rail.element.style.top) - partData.height / 2}px`;
    rail.parts.push(part);
    rail.widthUsed += partData.width; // Add the part's width to rail.widthUsed
    currentXPosition += partData.width; // Move currentXPosition by the part's width
  }

  panel.appendChild(part);

  // Add drag-and-drop functionality for all parts
  let isDragging = false;
  let offsetX, offsetY;

  part.addEventListener('mousedown', (e) => {
    isDragging = true;
    offsetX = e.clientX - part.getBoundingClientRect().left;
    offsetY = e.clientY - part.getBoundingClientRect().top;
    part.style.cursor = 'grabbing';
  });

  document.addEventListener('mousemove', (e) => {
    if (isDragging) {
      const x = e.clientX - offsetX - panel.getBoundingClientRect().left;
      const y = e.clientY - offsetY - panel.getBoundingClientRect().top;

      // Prevent parts from being placed outside the rail ends
      const minX = 0;
      const maxX = panel.offsetWidth - part.offsetWidth;
      const clampedX = Math.max(minX, Math.min(x, maxX));

      // Snap to the nearest rail
      const partRect = part.getBoundingClientRect();
      const panelRect = panel.getBoundingClientRect();
      const partCenterY = partRect.top + partRect.height / 2 - panelRect.top;

      let nearestRail = null;
      let minDistance = Infinity;

      rails.forEach((rail) => {
        const railRect = rail.element.getBoundingClientRect();
        const railCenterY = railRect.top + railRect.height / 2 - panelRect.top;
        const distance = Math.abs(partCenterY - railCenterY);

        if (distance < minDistance) {
          minDistance = distance;
          nearestRail = rail;
        }
      });

      if (nearestRail) {
        const railRect = nearestRail.element.getBoundingClientRect();
        const railTop = railRect.top - panelRect.top;
        part.style.top = `${railTop - partRect.height / 2}px`;
      }

      // Prevent overlapping of parts (except for ZUM-HUB4 and CEN-SWPOE-5AC)
      if (partType !== 'ZUM-HUB4' && partType !== 'CEN-SWPOE-5AC') {
        let isOverlap = false;
        rails.forEach((rail) => {
          rail.parts.forEach((otherPart) => {
            if (otherPart !== part) {
              const otherRect = otherPart.getBoundingClientRect();
              if (
                clampedX < otherRect.right &&
                clampedX + part.offsetWidth > otherRect.left &&
                partRect.top < otherRect.bottom &&
                partRect.bottom > otherRect.top
              ) {
                isOverlap = true;
              }
            }
          });
        });

        if (!isOverlap) {
          part.style.left = `${clampedX}px`;
        }
      } else {
        part.style.left = `${clampedX}px`;
      }
    }
  });

  document.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      part.style.cursor = 'grab';
    }
  });

  // Add space name to the part
  const spaceName = document.createElement('div');
  spaceName.className = 'space-name';
  spaceName.textContent = `Space ${spaceCounter}`;
  part.appendChild(spaceName);

  // Adjust font size dynamically
  adjustFontSize(spaceName, part);

  // Add part data to partsData array
  partsData.push({
    partElement: part,
    partType: partType,
    spaceName: `Space ${spaceCounter}`,
    circuitNumber: null,
    zone: null,
    lightingLoad: null,
    deviceMA: null,
  });

  // Increment space counter if the part is a ZUMNET device
  if (partType.startsWith('ZUMNET')) {
    spaceCounter++;
  }
}

function adjustFontSize(spaceName, part) {
  const partWidth = part.offsetWidth;
  const spaceNameWidth = spaceName.offsetWidth;
  let fontSize = 10;

  while (spaceNameWidth > partWidth && fontSize > 6) {
    fontSize--;
    spaceName.style.fontSize = `${fontSize}px`;
  }
}

function showPartPopup(partType, partElement) {
  const partPopup = document.getElementById('part-popup');
  const partForm = document.getElementById('part-form');

  // Find the part data
  const partData = partsData.find((p) => p.partElement === partElement);

  // Populate the form with existing data
  document.getElementById('space-name').value = partData.spaceName;
  document.getElementById('circuit-number').value = partData.circuitNumber || '';
  document.getElementById('zone').value = partData.zone || '';
  document.getElementById('lighting-load').value = partData.lightingLoad || '';
  document.getElementById('device-ma').value = partData.deviceMA || '';

  // Show the popup
  partPopup.style.display = 'block';

  // Handle form submission
  partForm.onsubmit = (e) => {
    e.preventDefault();

    // Update part data
    partData.spaceName = document.getElementById('space-name').value;
    partData.circuitNumber = document.getElementById('circuit-number').value;
    partData.zone = document.getElementById('zone').value;
    partData.lightingLoad = document.getElementById('lighting-load').value;
    partData.deviceMA = document.getElementById('device-ma').value;

    // Update the part's space name
    const spaceNameElement = partElement.querySelector('.space-name');
    spaceNameElement.textContent = partData.spaceName;
    adjustFontSize(spaceNameElement, partElement);

    // Update the data indicator (exclude deviceMA from the check)
    const dataIndicator = partElement.querySelector('.data-indicator');
    if (partData.circuitNumber && partData.zone && partData.lightingLoad) {
      dataIndicator.classList.add('green');
      dataIndicator.classList.remove('red');
    } else {
      dataIndicator.classList.add('red');
      dataIndicator.classList.remove('green');
    }

    // Hide the popup
    partPopup.style.display = 'none';

    // Update tables
    updateSpaceTable();
    updateLoadSchedule();
  };
}

function updateSpaceTable() {
  const spaceTableBody = document.querySelector('#space-table tbody');
  spaceTableBody.innerHTML = '';

  const spaceMap = {};

  partsData.forEach((part) => {
    if (part.partType === 'ZUMLINK-DIN-PSU') return; // Exclude ZUMLINK-DIN-PSU

    if (!spaceMap[part.spaceName]) {
      spaceMap[part.spaceName] = {
        parts: [],
        mA: 0,
        deviceMA: 0,
      };
    }

    // Add part and zone to the list
    spaceMap[part.spaceName].parts.push({ partType: part.partType, zone: part.zone });

    // Sum mA
    spaceMap[part.spaceName].mA += parts[part.partType].mA || 0;
    spaceMap[part.spaceName].deviceMA += part.deviceMA || 0;
  });

  Object.keys(spaceMap).forEach((spaceName) => {
    const row = document.createElement('tr');

    // Create nested table for Load Controller column
    const nestedTable = document.createElement('table');
    nestedTable.className = 'nested-table';
    spaceMap[spaceName].parts.forEach((part) => {
      const nestedRow = document.createElement('tr');
      nestedRow.innerHTML = `
        <td>${part.partType}</td>
        <td>${part.zone}</td>
      `;
      nestedTable.appendChild(nestedRow);
    });

    row.innerHTML = `
      <td><input type="text" value="${spaceName}" onchange="updateSpaceName('${spaceName}', this.value)"></td>
      <td></td>
      <td>${spaceMap[spaceName].mA} mA</td>
      <td>${spaceMap[spaceName].deviceMA} mA</td>
      <td>${spaceMap[spaceName].mA + spaceMap[spaceName].deviceMA} mA</td>
    `;
    row.querySelector('td:nth-child(2)').appendChild(nestedTable);
    spaceTableBody.appendChild(row);
  });
}

function updateLoadSchedule() {
  const loadTableBody = document.querySelector('#load-table tbody');
  loadTableBody.innerHTML = '';

  partsData.forEach((part) => {
    if (!part.circuitNumber) return;

    const row = document.createElement('tr');
    row.innerHTML = `
      <td>${part.spaceName}</td>
      <td>${part.circuitNumber}</td>
      <td>${part.zone}</td>
      <td>${part.partType}</td>
      <td>${part.lightingLoad} W</td>
      <td>${part.lightingLoad} W</td>
    `;
    loadTableBody.appendChild(row);
  });
}

function updateSpaceName(oldName, newName) {
  partsData.forEach((part) => {
    if (part.spaceName === oldName) {
      part.spaceName = newName;
    }
  });
  updateSpaceTable();
  updateLoadSchedule();
}

// Generate Panel Functionality
document.getElementById('generate-panel').addEventListener('click', () => {
  const wiringPanel = document.getElementById('wiring-panel');
  wiringPanel.innerHTML = panel.innerHTML; // Copy the panel contents
  wiringPanel.classList.add('non-editable'); // Make it non-editable
});

panelSelect.addEventListener('change', initializePanel);
document.querySelectorAll('.sidebar button[data-part]').forEach((button) => {
  button.addEventListener('click', () => {
    addPart(button.getAttribute('data-part'));
  });
});

initializePanel();

// Tab Switching Logic
const mainTabButton = document.getElementById('main-tab-button');
const wiringTabButton = document.getElementById('wiring-tab-button');
const spaceTabButton = document.getElementById('space-tab-button');
const loadTabButton = document.getElementById('load-tab-button');
const mainTab = document.getElementById('main-tab');
const wiringTab = document.getElementById('wiring-tab');
const spaceTab = document.getElementById('space-tab');
const loadTab = document.getElementById('load-tab');

mainTabButton.addEventListener('click', () => {
  mainTab.classList.add('active');
  wiringTab.classList.remove('active');
  spaceTab.classList.remove('active');
  loadTab.classList.remove('active');
  mainTabButton.classList.add('active');
  wiringTabButton.classList.remove('active');
  spaceTabButton.classList.remove('active');
  loadTabButton.classList.remove('active');
});

wiringTabButton.addEventListener('click', () => {
  wiringTab.classList.add('active');
  mainTab.classList.remove('active');
  spaceTab.classList.remove('active');
  loadTab.classList.remove('active');
  wiringTabButton.classList.add('active');
  mainTabButton.classList.remove('active');
  spaceTabButton.classList.remove('active');
  loadTabButton.classList.remove('active');
});

spaceTabButton.addEventListener('click', () => {
  spaceTab.classList.add('active');
  mainTab.classList.remove('active');
  wiringTab.classList.remove('active');
  loadTab.classList.remove('active');
  spaceTabButton.classList.add('active');
  mainTabButton.classList.remove('active');
  wiringTabButton.classList.remove('active');
  loadTabButton.classList.remove('active');
});

loadTabButton.addEventListener('click', () => {
  loadTab.classList.add('active');
  mainTab.classList.remove('active');
  wiringTab.classList.remove('active');
  spaceTab.classList.remove('active');
  loadTabButton.classList.add('active');
  mainTabButton.classList.remove('active');
  wiringTabButton.classList.remove('active');
  spaceTabButton.classList.remove('active');
});

// Wire Drawing Logic
const wiringSvg = document.getElementById('wiring-svg');
const wirePopup = document.getElementById('wire-popup');
const drawWiringButton = document.getElementById('draw-wiring');
const clearWiringButton = document.getElementById('clear-wiring');
let isDrawing = false;
let currentWireType = 'POWER'; // Default wire type
let wirePoints = []; // Stores the points of the current wire
let previewLine = null; // Preview line for the wire
let lastPoint = null; // Last point in the wire

// Show wire selection popup
drawWiringButton.addEventListener('click', () => {
  if (!isDrawing) {
    wirePopup.style.display = 'block';
  }
});

// Handle wire type selection
wirePopup.querySelectorAll('button').forEach((button) => {
  button.addEventListener('click', () => {
    currentWireType = button.getAttribute('data-type');
    wirePopup.style.display = 'none';
    startDrawing();
  });
});

// Start drawing a wire
function startDrawing() {
  isDrawing = true;
  wirePoints = [];
  lastPoint = null;
  wiringSvg.style.pointerEvents = 'all';
  wiringSvg.addEventListener('click', handleClick);
  document.addEventListener('keydown', handleKeyDown);
  wiringSvg.addEventListener('mousemove', handleMouseMove);
}

// Handle mouse clicks to add points
function handleClick(e) {
  const rect = wiringSvg.getBoundingClientRect();
  let x = e.clientX - rect.left;
  let y = e.clientY - rect.top;

  // Check if the click is near a dot
  const nearestDot = findNearestDot(x, y);
  if (nearestDot) {
    x = nearestDot.x;
    y = nearestDot.y;
  }

  if (!lastPoint) {
    // First click: start the wire
    wirePoints.push({ x, y });
    lastPoint = { x, y };
  } else {
    // Subsequent clicks: add a new point in 90-degree direction
    const dx = x - lastPoint.x;
    const dy = y - lastPoint.y;

    if (Math.abs(dx) > Math.abs(dy)) {
      // Horizontal movement
      wirePoints.push({ x, y: lastPoint.y });
    } else {
      // Vertical movement
      wirePoints.push({ x: lastPoint.x, y });
    }

    lastPoint = wirePoints[wirePoints.length - 1];
    drawWireSegment();
  }
}

// Handle keydown events (Enter to end wire, Ctrl+Z to undo, Ctrl+Y to redo)
function handleKeyDown(e) {
  if (e.key === 'Enter') {
    if (wirePoints.length > 1) {
      // Draw the final wire
      drawWireSegment();
      endDrawing();
    }
  } else if (e.ctrlKey && e.key === 'z') {
    undo();
  } else if (e.ctrlKey && e.key === 'y') {
    redo();
  }
}

// Handle mouse movement to show preview
function handleMouseMove(e) {
  if (!isDrawing || wirePoints.length === 0) return;

  const rect = wiringSvg.getBoundingClientRect();
  let x = e.clientX - rect.left;
  let y = e.clientY - rect.top;

  // Check if the mouse is near a dot
  const nearestDot = findNearestDot(x, y);
  if (nearestDot) {
    x = nearestDot.x;
    y = nearestDot.y;
  }

  // Remove existing preview line
  if (previewLine) {
    previewLine.remove();
  }

  // Draw preview line in 90-degree direction
  const lastPoint = wirePoints[wirePoints.length - 1];
  const dx = x - lastPoint.x;
  const dy = y - lastPoint.y;

  if (Math.abs(dx) > Math.abs(dy)) {
    // Horizontal preview
    previewLine = drawLine(lastPoint.x, lastPoint.y, x, lastPoint.y, currentWireType, true);
  } else {
    // Vertical preview
    previewLine = drawLine(lastPoint.x, lastPoint.y, lastPoint.x, y, currentWireType, true);
  }
}

// Draw a wire segment between the last two points
function drawWireSegment() {
  if (wirePoints.length < 2) return;

  const start = wirePoints[wirePoints.length - 2];
  const end = wirePoints[wirePoints.length - 1];
  drawLine(start.x, start.y, end.x, end.y, currentWireType);
}

// Draw a line between two points
function drawLine(x1, y1, x2, y2, type, isPreview = false) {
  const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  line.setAttribute('x1', x1);
  line.setAttribute('y1', y1);
  line.setAttribute('x2', x2);
  line.setAttribute('y2', y2);
  line.setAttribute('stroke', getWireColor(type));
  line.setAttribute('stroke-width', '2');

  if (type === 'DMX') {
    line.setAttribute('stroke-dasharray', '5,5');
  }

  if (isPreview) {
    line.setAttribute('stroke-opacity', '0.5');
  }

  wiringSvg.appendChild(line);
  return line;
}

// End drawing and reset state
function endDrawing() {
  isDrawing = false;
  wirePoints = [];
  lastPoint = null;
  wiringSvg.removeEventListener('click', handleClick);
  document.removeEventListener('keydown', handleKeyDown);
  wiringSvg.removeEventListener('mousemove', handleMouseMove);

  // Remove preview line
  if (previewLine) {
    previewLine.remove();
    previewLine = null;
  }

  // Wait 2 seconds before allowing the next wire run
  setTimeout(() => {
    wiringSvg.style.pointerEvents = 'none';
  }, 2000);
}

// Get wire color based on type
function getWireColor(type) {
  switch (type) {
    case 'CRESNET': return 'green';
    case 'ETHERNET': return 'blue';
    case 'ZUMNET': return 'purple';
    case 'ZUMLINK': return 'orange';
    case 'POWER': return 'black';
    case 'DMX': return 'url(#rainbow)';
    default: return 'black';
  }
}

// Clear all wires
clearWiringButton.addEventListener('click', () => {
  wiringSvg.innerHTML = '';
  // Re-add the gradient definition for DMX wires
  wiringSvg.appendChild(defs);
});

// Add rainbow gradient for DMX wires
const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
gradient.setAttribute('id', 'rainbow');
gradient.setAttribute('x1', '0%');
gradient.setAttribute('y1', '0%');
gradient.setAttribute('x2', '100%');
gradient.setAttribute('y2', '0%');
gradient.innerHTML = `
  <stop offset="0%" style="stop-color:red;stop-opacity:1" />
  <stop offset="16.67%" style="stop-color:orange;stop-opacity:1" />
  <stop offset="33.33%" style="stop-color:yellow;stop-opacity:1" />
  <stop offset="50%" style="stop-color:green;stop-opacity:1" />
  <stop offset="66.67%" style="stop-color:blue;stop-opacity:1" />
  <stop offset="83.33%" style="stop-color:indigo;stop-opacity:1" />
  <stop offset="100%" style="stop-color:violet;stop-opacity:1" />
`;
defs.appendChild(gradient);
wiringSvg.appendChild(defs);

// Function to find the nearest dot
function findNearestDot(x, y) {
  let nearestDot = null;
  let minDistance = Infinity;
  const threshold = 20; // Distance threshold for snapping (in pixels)

  // Loop through all parts and their dots
  document.querySelectorAll('.part').forEach((part) => {
    const partRect = part.getBoundingClientRect();
    const dots = part.querySelectorAll('.dot');

    dots.forEach((dot) => {
      const dotRect = dot.getBoundingClientRect();
      const dotCenterX = dotRect.left + dotRect.width / 2 - partRect.left;
      const dotCenterY = dotRect.top + dotRect.height / 2 - partRect.top;

      // Calculate distance between wire endpoint and dot center
      const distance = Math.sqrt((x - dotCenterX) ** 2 + (y - dotCenterY) ** 2);

      // Check if this dot is the nearest
      if (distance < threshold && distance < minDistance) {
        minDistance = distance;
        nearestDot = { x: dotCenterX, y: dotCenterY };
      }
    });
  });

  return nearestDot;
}

// Undo functionality
let undoStack = [];
let redoStack = [];

function undo() {
  if (undoStack.length > 0) {
    const lastWire = undoStack.pop();
    redoStack.push(lastWire);
    lastWire.remove();
  }
}

// Redo functionality
function redo() {
  if (redoStack.length > 0) {
    const lastWire = redoStack.pop();
    undoStack.push(lastWire);
    wiringSvg.appendChild(lastWire);
  }
}
</script>
</body>
</html>
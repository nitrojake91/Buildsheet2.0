<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced Panel and Parts Configuration</title>
  <style>
    /* Full CSS */
    :root {
      --primary-color: #003366;
      --secondary-color: #0099CC;
      --accent-color: #FF6600;
      --background-color: #F5F5F5;
      --text-color: #333333;
      --button-gradient: linear-gradient(135deg, #0099CC, #003366);
      --button-hover-gradient: linear-gradient(135deg, #0077B3, #002244);
      --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --shadow-hover: 0 6px 12px rgba(0, 0, 0, 0.2);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
.red-dot {
  width: 10px;
  height: 10px;
  background-color: red;
  border-radius: 50%;
  position: absolute;
}
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--background-color);
      color: var(--text-color);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      width: 100%;
      min-width: 120px;
      background-color: white;
      border-radius: 30px;
      box-shadow: var(--shadow);
      overflow: auto;
      height: 6000px;
    }

    .tab-buttons {
      display: flex;
      gap: 10px;
      padding: 20px;
      background-color: var(--primary-color);
      border-radius: 12px 12px 0 0;
    }

    .tab-buttons button {
      padding: 10px 20px;
      background: var(--button-gradient);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      box-shadow: var(--shadow);
    }

    .tab-buttons button:hover {
      background: var(--button-hover-gradient);
      box-shadow: var(--shadow-hover);
      transform: translateY(-2px);
    }

    .tab-buttons button.active {
      background: var(--accent-color);
    }

    .tab {
      display: none;
      padding: 20px;
    }

    .tab.active {
      display: flex;
      gap: 20px;
    }

    .sidebar {
      width: 250px;
      background-color: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: var(--shadow);
    }

    .sidebar button {
      width: 100%;
      padding: 10px;
      margin: 10px 0;
      background: var(--button-gradient);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      box-shadow: var(--shadow);
    }

    .sidebar button:hover {
      background: var(--button-hover-gradient);
      box-shadow: var(--shadow-hover);
      transform: translateY(-2px);
    }

    .panel-container {
      flex: 2;
      border-radius: 12px;
      box-shadow: var(--shadow);
      position: relative;
      overflow: 2000px;
      height: 2000px;
    }

    .rail-graphic {
      position: absolute;
      background-color: var(--secondary-color);
      height: 18px;
      padding: 20px;
      width: 324px;
      border-radius: 4px;
      z-index: 1;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    .part {
      position: absolute;
      padding: -10px;
      background-color: var(--accent-color);
      border: none;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 10px;
      text-align: center;
      flex-direction: column;
      z-index: 2;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      cursor: grab;
      border: 2px solid rgba(255, 255, 255, 0.5);
      animation: float 3s infinite ease-in-out;
    }

    @keyframes float {
      0%, 100% {
        transform: translateY(0);
      }
      50% {
        transform: translateY(-10px);
      }
    }

    .part .dots {
      display: flex;
      gap: 10px;
      position: absolute;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
    }

    .part .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      border: 1px solid black;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .part .data-indicator {
      position: absolute;
      top: 5px;
      left: 5px;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background-color: red;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .part .data-indicator.green {
      background-color: green;
    }

    .part .arrows {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      pointer-events: none;
    }

    .part .arrows button {
      pointer-events: all;
      background: rgba(255, 255, 255, 0.8);
      border: none;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: var(--shadow);
    }

    .part .arrows button:hover {
      background: white;
    }

    .wiring-svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: all;
    }

    /* Wiring Container */
    #wiring-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .wiring-svg path {
      stroke-width: 18; /* Increased wire thickness */
      fill: none;
    }

    .wire-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: var(--shadow);
      z-index: 1000;
    }

    .wire-popup button {
      width: 100%;
      padding: 10px;
      margin: 10px 0;
      background: var(--button-gradient);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      box-shadow: var(--shadow);
    }

    .wire-popup button:hover {
      background: var(--button-hover-gradient);
      box-shadow: var(--shadow-hover);
      transform: translateY(-2px);
    }

    .space-layout,
    .load-schedule {
      padding: 20px;
    }

    .space-layout h2,
    .load-schedule h2 {
      margin-bottom: 20px;
    }

    .space-layout table,
    .load-schedule table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }

    .space-layout th,
    .space-layout td,
    .load-schedule th,
    .load-schedule td {
      padding: 10px;
      border: 1px solid #ddd;
      text-align: left;
    }

    .space-layout th,
    .load-schedule th {
      background-color: var(--primary-color);
      color: white;
    }

    .space-layout tr:nth-child(even),
    .load-schedule tr:nth-child(even) {
      background-color: #f9f9f9;
    }

    .space-layout input[type="text"],
    .space-layout input[type="number"] {
      width: 100%;
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .nested-table {
      width: 100%;
      border-collapse: collapse;
    }

    .nested-table td {
      padding: 5px;
      border: 1px solid #ddd;
    }

    .non-editable {
      pointer-events: none; /* Disable pointer events */
      cursor: default; /* Set cursor to default */
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Tab Buttons -->
    <div class="tab-buttons">
      <button id="main-tab-button" class="active">Main Page</button>
      <button id="wiring-tab-button">Panel Wiring</button>
      <button id="space-tab-button">Space Layout</button>
      <button id="load-tab-button">Load Schedule</button>
      <button id="print-pdf-button">Print to PDF</button>
    </div>

    <!-- Main Page Tab -->
    <div id="main-tab" class="tab active">
      <div class="sidebar">
        <label for="panel-select">Panel Selection:</label>
        <select id="panel-select">
          <option value="DIN-EN-2X18">DIN-EN-2X18</option>
          <option value="DIN-EN-3X18">DIN-EN-3X18</option>
          <option value="DIN-EN-6X18">DIN-EN-6X18</option>
          <option value="DIN-EN-10X18">DIN-EN-10X18</option>
        </select>
        <button data-part="ZUMNET-DIN-DLI">Add ZUMNET-DIN-DLI</button>
        <button data-part="ZUMNET-DIN-16A-LV">Add ZUMNET-DIN-16A-LV</button>
        <button data-part="ZUMLINK-DIN-PSU">Add ZUMLINK-DIN-PSU</button>
        <button data-part="ZUMLINK-DIN-IO">Add ZUMLINK-DIN-IO</button>
        <button data-part="ZUM-HUB4">Add ZUM-HUB4</button>
        <button data-part="CEN-SWPOE-5AC">Add CEN-SWPOE-5AC</button>
        <button data-part="ZUMLINK-DIN-16A-LV">Add ZUMLINK-DIN-16A-LV</button>
        <button data-part="ZUMLINK-DIN-20A-SW">Add ZUMLINK-DIN-20A-SW</button>
        <button data-part="ZUMLINK-DIN-20A-PLUG">Add ZUMLINK-DIN-20A-PLUG</button>
        <button data-part="ZUMLINK-DIN-DIMU">Add ZUMLINK-DIN-DIMU</button>
        <button data-part="DIN-DMX">Add DIN-DMX</button>
        <button data-part="DIN-AP4">Add DIN-AP4</button>
        <button data-part="DIN-PWS60">Add DIN-PWS60</button>
        <button data-part="DIN-DALI-2">Add DIN-DALI-2</button>
      </div>
      <div class="panel-container" id="panel-container">
        <div class="panel" id="panel"></div>
      </div>
    </div>

    <!-- Panel Wiring Tab -->
    <div id="wiring-tab" class="tab">
      <div class="sidebar">
        <button id="generate-panel">Generate Panel</button>
        <button id="auto-wiring-button">Auto Wiring</button>
        <button id="auto-wire-zumnets-button">Auto Wire Zumnets</button>
        <button id="draw-wiring">Draw Wiring</button>
        <button id="clear-wiring">Clear All Wiring</button>
      </div>
      <div class="panel-container">
        <div id="wiring-panel" class="panel"></div>
        <svg class="wiring-svg" id="wiring-svg"></svg>
      </div>
    </div>

    <!-- Space Layout Tab -->
    <div id="space-tab" class="tab">
      <div class="space-layout">
        <h2>Space Layout</h2>
        <table id="space-table">
          <thead>
            <tr>
              <th>Space Name</th>
              <th>Load Controller</th>
              <th>mA Draw</th>
              <th>Device mA</th>
              <th>Total Power Draw</th>
            </tr>
          </thead>
          <tbody>
            <!-- Rows will be dynamically added here -->
          </tbody>
        </table>
      </div>
    </div>

    <!-- Load Schedule Tab -->
    <div id="load-tab" class="tab">
      <div class="load-schedule">
        <h2>Load Schedule</h2>
        <table id="load-table">
          <thead>
            <tr>
              <th>Space Name</th>
              <th>Circuit #</th>
              <th>Zone</th>
              <th>Load Controller</th>
              <th>Lighting Load</th>
              <th>Circuit Load Total</th>
            </tr>
          </thead>
          <tbody>
            <!-- Rows will be dynamically added here -->
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Part Information Popup -->
  <div id="part-popup" class="wire-popup" style="display: none;">
    <h3>Part Information</h3>
    <form id="part-form">
      <label for="space-name">Space Name*:</label>
      <input type="text" id="space-name" required>
      <label for="circuit-number">Circuit #:</label>
      <input type="text" id="circuit-number">
      <label for="zone">Zone:</label>
      <input type="text" id="zone">
      <label for="lighting-load">Lighting Load (watts):</label>
      <input type="number" id="lighting-load">
      <label for="device-ma">Device mA:</label>
      <input type="number" id="device-ma">
      <button type="submit">Save</button>
    </form>
  </div>

  <!-- Wire Selection Popup -->
  <div id="wire-popup" class="wire-popup" style="display: none;">
    <h3>Select Wire Type</h3>
    <button data-type="CRESNET">CRESNET (Green)</button>
    <button data-type="ETHERNET">ETHERNET (Blue)</button>
    <button data-type="ZUMNET">ZUMNET (Purple)</button>
    <button data-type="ZUMLINK">ZUMLINK (Orange)</button>
    <button data-type="POWER">POWER (Black)</button>
    <button data-type="DMX">DMX (Rainbow Dotted)</button>
  </div>

  <!-- Add the html2canvas and jsPDF libraries -->
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.24/jspdf.plugin.autotable.min.js"></script>
 <script>
    const { jsPDF } = window.jspdf;

// Main Page Logic
const panelSelect = document.getElementById('panel-select');
const panel = document.getElementById('panel');
const parts = {
  'ZUMNET-DIN-DLI': { width: 71, height: 94, color: 'purple', mA: 150, dots: ['purple', 'purple', 'orange', 'orange'] },
  'ZUMNET-DIN-16A-LV': { width: 71, height: 71, color: 'purple', mA: 120, dots: ['purple', 'purple', 'orange', 'orange'] },
  'ZUMLINK-DIN-PSU': { width: 71, height: 71, color: 'grey', mA: 0, dots: ['orange', 'orange', 'orange', 'orange'] }, // Excluded
  'ZUMLINK-DIN-IO': { width: 71, height: 94, color: 'orange', mA: 145, dots: ['orange', 'orange'] },
  'ZUM-HUB4': { width: 165, height: 439, dots: ['green', 'purple', 'purple'] },
  'CEN-SWPOE-5AC': { width: 187, height: 120, dots: ['blue', 'blue', 'blue', 'blue', 'blue'] },
  'ZUMLINK-DIN-16A-LV': { width: 53, height: 94, color: 'orange', mA: 100, dots: ['orange', 'orange'] },
  'ZUMLINK-DIN-20A-SW': { width: 53, height: 94, color: 'orange', mA: 50, dots: ['orange', 'orange'] },
  'ZUMLINK-DIN-20A-PLUG': { width: 53, height: 71, color: 'orange', mA: 50, dots: ['orange', 'orange'] },
  'ZUMLINK-DIN-DIMU': { width: 53, height: 94, color: 'orange', mA: 100, dots: ['orange', 'orange'] },
  'DIN-DMX': { width: 144, height: 90, dots: ['blue', 'black', 'grey', 'grey'] },
  'DIN-AP4': { width: 161, height: 91, dots: ['green', 'green', 'blue'] },
  'DIN-PWS60': { width: 108, height: 94, dots: ['green', 'green', 'green', 'black'] },
  'DIN-DALI-2': { width: 159, height: 95, dots: ['blue', 'green'] },
  'TERMINAL RAIL': { width: 80, height: 50, color: 'multi', dots: [] },
};

const panelSizes = {
  'DIN-EN-2X18': { width: 324, height: 323, rails: 2 }, // Fixed panel and rail width to 324mm
  'DIN-EN-3X18': { width: 324, height: 597, rails: 3 },
  'DIN-EN-6X18': { width: 324, height: 989, rails: 6 },
  'DIN-EN-10X18': { width: 324, height: 1594, rails: 10 },
};

let rails = [];
let currentRailIndex = 0;
let currentXPosition = 0;
let partsData = [];
let spaceCounter = 1;

function initializePanel() {
  const selectedPanel = panelSelect.value;
  const { width, height, rails: railCount } = panelSizes[selectedPanel];
  panel.style.width = `${width}px`; // Set panel width to 324mm
  panel.style.height = `${height}px`;
  panel.innerHTML = '';

  rails = [];
  const railSpacing = (height / (railCount + 1)) * 1.3; // Increase spacing by 30%
  for (let i = 1; i <= railCount; i++) {
    const rail = document.createElement('div');
    rail.className = 'rail-graphic';
    rail.style.top = `${railSpacing * i - 80}px`;
    rail.style.left = '20px'; // Align rails to the left
    panel.appendChild(rail);
    rails.push({ element: rail, parts: [], widthUsed: 0 });
  }

  currentRailIndex = 0;
  currentXPosition = 25; // Start from the left edge
}

function addPart(partType, position = null) {
  const partData = parts[partType];
  if (currentRailIndex >= rails.length) {
    alert('No more rails available in this panel!');
    return;
  }

  // Check if the part will exceed the rail width
  if (rails[currentRailIndex].widthUsed + partData.width > 324) {
    currentRailIndex++; // Move to the next rail
    currentXPosition = 25; // Reset X position
    if (currentRailIndex >= rails.length) {
      alert('No more rails available in this panel!');
      return;
    }
  }

  const part = document.createElement('div');
  part.className = 'part draggable';
  part.style.width = `${partData.width}px`;
  part.style.height = `${partData.height}px`;
  part.textContent = partType;
  part.style.backgroundColor = partData.color || '#4CAF50';

  // Add color dots
  const dotsContainer = document.createElement('div');
  dotsContainer.className = 'dots';
  partData.dots.forEach((dotColor) => {
    const dot = document.createElement('div');
    dot.className = 'dot';
    dot.style.backgroundColor = dotColor;
    dotsContainer.appendChild(dot);
  });
  part.appendChild(dotsContainer);

  // Add data indicator (red/green dot)
  const dataIndicator = document.createElement('div');
  dataIndicator.className = 'data-indicator';
  part.appendChild(dataIndicator);

  // Add double-click to edit
  part.addEventListener('dblclick', () => showPartPopup(partType, part));

  // Add right-click to delete with confirmation popup
  part.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    const confirmDelete = confirm('Are you sure you want to delete this part?');
    if (confirmDelete) {
      part.remove();
      partsData = partsData.filter((p) => p.partElement !== part);
      updateSpaceTable();
      updateLoadSchedule();
    }
  });

  if (position) {
    // Place the part at the specified position
    part.style.left = `${position.left}px`;
    part.style.top = `${position.top}px`;
  } else {
    const rail = rails[currentRailIndex];

    // Position the part
    part.style.left = `${currentXPosition}px`;
    part.style.top = `${parseInt(rail.element.style.top) - partData.height / 2}px`;
    rail.parts.push(part);
    rail.widthUsed += partData.width; // Add the part's width to rail.widthUsed
    currentXPosition += partData.width; // Move currentXPosition by the part's width
  }

  panel.appendChild(part);

  // Determine the default space name
  let spaceName = `Space ${spaceCounter}`;

  // Logic for ZUMNET parts
  if (partType.startsWith('ZUMNET')) {
    // Find the last ZUMNET part added
    const lastZUMNET = partsData
      .filter((p) => p.partType.startsWith('ZUMNET'))
      .pop();

    if (lastZUMNET) {
      // Extract the space number from the last ZUMNET's space name
      const lastSpaceNumber = parseInt(lastZUMNET.spaceName.split(' ')[1]);
      spaceName = `Space ${lastSpaceNumber + 1}`;
    } else {
      // If no ZUMNET parts have been added yet, default to Space 1
      spaceName = `Space 1`;
    }
  }

  // Logic for ZUMLINK parts (excluding ZUMLINK-DIN-IO)
  if (partType.startsWith('ZUMLINK') && partType !== 'ZUMLINK-DIN-IO') {
    const rail = rails[currentRailIndex];
    const currentIndex = rail.parts.length - 1; // Index of the current part

    if (currentIndex > 0) {
      // If there's a part to the left, mimic its space name
      const leftPart = rail.parts[currentIndex - 1];
      const leftPartData = partsData.find((p) => p.partElement === leftPart);
      if (leftPartData) {
        spaceName = leftPartData.spaceName;
      }
    } else if (currentRailIndex > 0) {
      // If this is the first part on a new row, look to the last part on the row above
      const railAbove = rails[currentRailIndex - 1];
      if (railAbove.parts.length > 0) {
        const lastPartAbove = railAbove.parts[railAbove.parts.length - 1];
        const lastPartAboveData = partsData.find((p) => p.partElement === lastPartAbove);
        if (lastPartAboveData) {
          spaceName = lastPartAboveData.spaceName;
        }
      }
    }
  }

  // Add space name to the part
  const spaceNameElement = document.createElement('div');
  spaceNameElement.className = 'space-name';
  spaceNameElement.textContent = spaceName;
  part.appendChild(spaceNameElement);

  // Add part data to partsData array
  partsData.push({
    partElement: part,
    partType: partType,
    spaceName: spaceName,
    circuitNumber: null,
    zone: null,
    lightingLoad: null,
    deviceMA: null,
  });

  // Increment space counter if the part is a ZUMNET device
  if (partType.startsWith('ZUMNET')) {
    spaceCounter++;
  }
}

function adjustFontSize(spaceName, part) {
  const partWidth = part.offsetWidth;
  const spaceNameWidth = spaceName.offsetWidth;
  let fontSize = 10;

  while (spaceNameWidth > partWidth && fontSize > 6) {
    fontSize--;
    spaceName.style.fontSize = `${fontSize}px`;
  }
}

function showPartPopup(partType, partElement) {
  const partPopup = document.getElementById('part-popup');
  const partForm = document.getElementById('part-form');

  // Find the part data
  const partData = partsData.find((p) => p.partElement === partElement);

  // Populate the form with existing data
  document.getElementById('space-name').value = partData.spaceName;
  document.getElementById('circuit-number').value = partData.circuitNumber || '';
  document.getElementById('zone').value = partData.zone || '';
  document.getElementById('lighting-load').value = partData.lightingLoad || '';
  document.getElementById('device-ma').value = partData.deviceMA || '';

  // Show the popup
  partPopup.style.display = 'block';

  // Handle form submission
  partForm.onsubmit = (e) => {
    e.preventDefault();

    // Update part data
    partData.spaceName = document.getElementById('space-name').value;
    partData.circuitNumber = document.getElementById('circuit-number').value;
    partData.zone = document.getElementById('zone').value;
    partData.lightingLoad = document.getElementById('lighting-load').value;
    partData.deviceMA = document.getElementById('device-ma').value;

    // Update the part's space name
    const spaceNameElement = partElement.querySelector('.space-name');
    spaceNameElement.textContent = partData.spaceName;
    adjustFontSize(spaceNameElement, partElement);

    // Update the data indicator (exclude deviceMA from the check)
    const dataIndicator = partElement.querySelector('.data-indicator');
    if (partData.circuitNumber && partData.zone && partData.lightingLoad) {
      dataIndicator.classList.add('green');
      dataIndicator.classList.remove('red');
    } else {
      dataIndicator.classList.add('red');
      dataIndicator.classList.remove('green');
    }

    // Hide the popup
    partPopup.style.display = 'none';

    // Update tables
    updateSpaceTable();
    updateLoadSchedule();
  };
}

function updateSpaceTable() {
  const spaceTableBody = document.querySelector('#space-table tbody');
  spaceTableBody.innerHTML = '';

  const spaceMap = {};

  partsData.forEach((part) => {
    if (part.partType === 'ZUMLINK-DIN-PSU') return; // Exclude ZUMLINK-DIN-PSU

    if (!spaceMap[part.spaceName]) {
      spaceMap[part.spaceName] = {
        parts: [],
        mA: 0,
        deviceMA: 0,
      };
    }

    // Add part and zone to the list
    spaceMap[part.spaceName].parts.push({ partType: part.partType, zone: part.zone });

    // Sum mA
    spaceMap[part.spaceName].mA += parts[part.partType].mA || 0;
    spaceMap[part.spaceName].deviceMA += part.deviceMA || 0;
  });

  Object.keys(spaceMap).forEach((spaceName) => {
    const row = document.createElement('tr');

    // Create nested table for Load Controller column
    const nestedTable = document.createElement('table');
    nestedTable.className = 'nested-table';
    spaceMap[spaceName].parts.forEach((part) => {
      const nestedRow = document.createElement('tr');
      nestedRow.innerHTML = `
        <td>${part.partType}</td>
        <td>${part.zone}</td>
      `;
      nestedTable.appendChild(nestedRow);
    });

    row.innerHTML = `
      <td><input type="text" value="${spaceName}" onchange="updateSpaceName('${spaceName}', this.value)"></td>
      <td></td>
      <td>${spaceMap[spaceName].mA} mA</td>
      <td>${spaceMap[spaceName].deviceMA} mA</td>
      <td>${spaceMap[spaceName].mA + spaceMap[spaceName].deviceMA} mA</td>
    `;
    row.querySelector('td:nth-child(2)').appendChild(nestedTable);
    spaceTableBody.appendChild(row);
  });
}

function updateLoadSchedule() {
  const loadTableBody = document.querySelector('#load-table tbody');
  loadTableBody.innerHTML = '';

  partsData.forEach((part) => {
    if (!part.circuitNumber) return;

    const row = document.createElement('tr');
    row.innerHTML = `
      <td>${part.spaceName}</td>
      <td>${part.circuitNumber}</td>
      <td>${part.zone}</td>
      <td>${part.partType}</td>
      <td>${part.lightingLoad} W</td>
      <td>${part.lightingLoad} W</td>
    `;
    loadTableBody.appendChild(row);
  });
}

function updateSpaceName(oldName, newName) {
  partsData.forEach((part) => {
    if (part.spaceName === oldName) {
      part.spaceName = newName;
    }
  });
  updateSpaceTable();
  updateLoadSchedule();
}

document.getElementById('generate-panel').addEventListener('click', () => {
  const wiringPanel = document.getElementById('wiring-panel');
  wiringPanel.innerHTML = ''; // Clear the wiring panel

  // Get all parts from the main panel
  const parts = document.querySelectorAll('#panel .part');

  // Group parts by their vertical position (rows)
  const rows = {};
  parts.forEach((part) => {
    const top = part.style.top; // Get the top position of the part
    if (!rows[top]) {
      rows[top] = []; // Initialize a new row if it doesn't exist
    }
    rows[top].push(part); // Add the part to its respective row
  });

  let topOffset = 100; // Initialize the top offset for positioning rows

  // Iterate through each row and position the parts
  Object.values(rows).forEach((rowParts) => {
    let leftOffset = 100; // Initialize the left offset for positioning parts within a row

    // Sort parts in the row by their horizontal position (left)
    rowParts.sort((a, b) => parseInt(a.style.left) - parseInt(b.style.left));

    rowParts.forEach((part) => {
      const clonedPart = part.cloneNode(true); // Clone the part
      clonedPart.style.position = 'absolute'; // Ensure the part is positioned absolutely

      // Set the horizontal position with 50px spacing between parts
      clonedPart.style.left = `${leftOffset}px`;

      // Set the vertical position with 100px spacing between rows
      clonedPart.style.top = `${topOffset}px`;

      // Disable animations and make the part non-editable
      clonedPart.style.animation = 'none';
      clonedPart.classList.add('non-editable');

      // Add dots for wire connection points at the bottom of the part
      const dotsContainer = document.createElement('div');
      dotsContainer.className = 'dots-container';
      dotsContainer.style.position = 'absolute';
      dotsContainer.style.bottom = '0';
      dotsContainer.style.left = '50%';
      dotsContainer.style.transform = 'translateX(-50%)';
      dotsContainer.style.display = 'flex';
      dotsContainer.style.gap = '10px';

      // Determine the number and color of dots based on the part type or color
      const partType = part.getAttribute('data-part'); // Use the data-part attribute to identify the part
      const partColor = clonedPart.style.backgroundColor; // Get the background color of the part

      let dotColors = [];

      if (partColor === 'grey' || partColor === 'gray') {
        // Grey parts get 4 brown dots
        dotColors = ['brown', 'brown', 'brown', 'brown'];
      } else if (partColor === 'purple') {
        // Purple parts get 2 black and 2 red dots
        dotColors = ['black', 'black', 'red', 'red'];
      } else if (partColor === 'orange') {
        // Orange parts get 2 red dots
        dotColors = ['red', 'red'];
      }

      // Create and append the dots
      dotColors.forEach((color) => {
        const dot = document.createElement('div');
        dot.className = 'dot';
        dot.style.width = '10px';
        dot.style.height = '10px';
        dot.style.backgroundColor = color;
        dot.style.borderRadius = '50%';
        dotsContainer.appendChild(dot);
      });

      clonedPart.appendChild(dotsContainer);

      // Append the cloned part to the wiring panel
      wiringPanel.appendChild(clonedPart);

      // Update the left offset for the next part in the row
      leftOffset += clonedPart.offsetWidth + 50; // Add 50px horizontal spacing
    });

    // Update the top offset for the next row
    const maxHeightInRow = Math.max(...rowParts.map((part) => part.offsetHeight)); // Find the tallest part in the row
    topOffset += maxHeightInRow + 200; // Add 100px vertical spacing between rows
  });

  // Add a class to the wiring panel to disable further editing
  wiringPanel.classList.add('non-editable');
});

panelSelect.addEventListener('change', initializePanel);
document.querySelectorAll('.sidebar button[data-part]').forEach((button) => {
  button.addEventListener('click', () => {
    addPart(button.getAttribute('data-part'));
  });
});

initializePanel();

// Tab Switching Logic
const mainTabButton = document.getElementById('main-tab-button');
const wiringTabButton = document.getElementById('wiring-tab-button');
const spaceTabButton = document.getElementById('space-tab-button');
const loadTabButton = document.getElementById('load-tab-button');
const mainTab = document.getElementById('main-tab');
const wiringTab = document.getElementById('wiring-tab');
const spaceTab = document.getElementById('space-tab');
const loadTab = document.getElementById('load-tab');

mainTabButton.addEventListener('click', () => {
  mainTab.classList.add('active');
  wiringTab.classList.remove('active');
  spaceTab.classList.remove('active');
  loadTab.classList.remove('active');
  mainTabButton.classList.add('active');
  wiringTabButton.classList.remove('active');
  spaceTabButton.classList.remove('active');
  loadTabButton.classList.remove('active');
});

wiringTabButton.addEventListener('click', () => {
  wiringTab.classList.add('active');
  mainTab.classList.remove('active');
  spaceTab.classList.remove('active');
  loadTab.classList.remove('active');
  wiringTabButton.classList.add('active');
  mainTabButton.classList.remove('active');
  spaceTabButton.classList.remove('active');
  loadTabButton.classList.remove('active');
});

spaceTabButton.addEventListener('click', () => {
  spaceTab.classList.add('active');
  mainTab.classList.remove('active');
  wiringTab.classList.remove('active');
  loadTab.classList.remove('active');
  spaceTabButton.classList.add('active');
  mainTabButton.classList.remove('active');
  wiringTabButton.classList.remove('active');
  loadTabButton.classList.remove('active');
});

loadTabButton.addEventListener('click', () => {
  loadTab.classList.add('active');
  mainTab.classList.remove('active');
  wiringTab.classList.remove('active');
  spaceTab.classList.remove('active');
  loadTabButton.classList.add('active');
  mainTabButton.classList.remove('active');
  wiringTabButton.classList.remove('active');
  spaceTabButton.classList.remove('active');
});

// Auto Wire Logic (Red Wires)
document.getElementById('auto-wiring-button').addEventListener('click', () => {
  const parts = document.querySelectorAll('.part'); // Get all parts
  const redDots = [];

  // Step 1: Identify all red dots
  parts.forEach((part) => {
    const partRect = part.getBoundingClientRect();
    const dots = part.querySelectorAll('.dot');

    dots.forEach((dot) => {
      if (dot.style.backgroundColor === 'red') {
        const dotRect = dot.getBoundingClientRect();
        redDots.push({
          part,
          dot,
          x: dotRect.left + dotRect.width / 2 - partRect.left + part.offsetLeft,
          y: dotRect.top + dotRect.height / 2 - partRect.top + part.offsetTop,
        });
      }
    });
  });

  // Step 2: Wire red dots
  wireDots(redDots, 'red', true);
});

// Auto Wire Zumnets Logic (Black Wires)
let selectedZumnets = [];
let lastTappedZumnet = null;
let tapTimeout = null;

document.getElementById('auto-wire-zumnets-button').addEventListener('click', () => {
  const parts = document.querySelectorAll('.part'); // Get all parts

  if (selectedZumnets.length === 0) {
    // First click: Select Zumnets
    parts.forEach((part) => {
      if (part.textContent.startsWith('ZUMNET')) {
        part.style.border = '2px solid blue'; // Highlight selected Zumnets
        selectedZumnets.push(part);

        // Add double-click or single-tap to unselect
        part.addEventListener('dblclick', () => unselectZumnet(part)); // For mouse
        part.addEventListener('touchstart', () => handleTap(part)); // For touch screens
      }
    });
    alert('Zumnets selected. Click the "Auto Wire Zumnets" button again to wire them. Double-click or tap a Zumnet to unselect it.');
  } else {
    // Second click: Wire selected Zumnets with black wires
    wireSelectedZumnets(selectedZumnets);

    // Clear selection after wiring
    selectedZumnets.forEach((part) => {
      part.style.border = ''; // Remove highlight
      part.removeEventListener('dblclick', () => unselectZumnet(part)); // Remove the double-click listener
      part.removeEventListener('touchstart', () => handleTap(part)); // Remove the touch listener
    });
    selectedZumnets = []; // Reset selection
  }
});

// Function to handle single-tap on touch screens
function handleTap(part) {
  if (tapTimeout && lastTappedZumnet === part) {
    // If the same Zumnet is tapped again within the timeout, unselect it
    clearTimeout(tapTimeout);
    tapTimeout = null;
    unselectZumnet(part);
  } else {
    // Set a timeout to detect a single tap
    lastTappedZumnet = part;
    tapTimeout = setTimeout(() => {
      tapTimeout = null;
    }, 300); // 300ms timeout for double-tap detection
  }
}

// Function to unselect a Zumnet
function unselectZumnet(part) {
  part.style.border = ''; // Remove highlight
  selectedZumnets = selectedZumnets.filter((selectedPart) => selectedPart !== part); // Remove from selectedZumnets
  part.removeEventListener('dblclick', () => unselectZumnet(part)); // Remove the double-click listener
  part.removeEventListener('touchstart', () => handleTap(part)); // Remove the touch listener
}

function wireSelectedZumnets(zumnets) {
  const blackDots = [];

  // Step 1: Identify all black dots in the selected Zumnets
  zumnets.forEach((part) => {
    const partRect = part.getBoundingClientRect();
    const dots = part.querySelectorAll('.dot');

    dots.forEach((dot) => {
      if (dot.style.backgroundColor === 'black') {
        const dotRect = dot.getBoundingClientRect();
        blackDots.push({
          part,
          dot,
          x: dotRect.left + dotRect.width / 2 - partRect.left + part.offsetLeft,
          y: dotRect.top + dotRect.height / 2 - partRect.top + part.offsetTop,
        });
      }
    });
  });

  // Step 2: Wire black dots
  wireDots(blackDots, 'black', false);
}

// Helper function to wire dots (red or black)
function wireDots(dots, color, useSpaceNameRestriction) {
  // Step 1: Group dots by their space name (if using space name restriction)
  const spaceGroups = {};
  dots.forEach((dot) => {
    const groupKey = useSpaceNameRestriction ? dot.spaceName : 'all'; // Use space name or group all together
    if (!spaceGroups[groupKey]) {
      spaceGroups[groupKey] = [];
    }
    spaceGroups[groupKey].push(dot);
  });

  // Step 2: For each group, group dots by their Y-axis (rows)
  Object.values(spaceGroups).forEach((groupDots) => {
    const rows = {};
    groupDots.forEach((dot) => {
      if (!rows[dot.y]) {
        rows[dot.y] = [];
      }
      rows[dot.y].push(dot);
    });

    // Step 3: Sort rows by Y-axis (top to bottom)
    const sortedRows = Object.keys(rows).sort((a, b) => a - b);

    // Step 4: Connect dots in each row
    for (let i = 0; i < sortedRows.length; i++) {
      const rowY = sortedRows[i];
      const rowDots = rows[rowY].sort((a, b) => a.x - b.x); // Sort dots in the row from left to right

      // Skip the first dot in the row
      for (let j = 1; j < rowDots.length - 1; j += 2) {
        const startDot = rowDots[j];
        const endDot = rowDots[j + 1];

        // Draw wire from startDot to endDot
        const verticalOffset = color === 'black' ? 25 : 20; // Black wires come down 5px more
        drawWire([
          { x: startDot.x, y: startDot.y }, // Start at the start dot
          { x: startDot.x, y: startDot.y + verticalOffset }, // Go down (20px for red, 25px for black)
          { x: endDot.x, y: startDot.y + verticalOffset }, // Go over to the end dot
          { x: endDot.x, y: endDot.y }, // Go up to the end dot
        ], color);
      }

      // Handle the last dot in the row
      if (rowDots.length > 1 && rowDots.length % 2 === 0) {
        const lastDot = rowDots[rowDots.length - 1];

        // Check if there is a row below
        if (i < sortedRows.length - 1) {
          const nextRowY = sortedRows[i + 1];
          const nextRowDots = rows[nextRowY].sort((a, b) => a.x - b.x);

          if (nextRowDots.length > 0) {
            const firstDotNextRow = nextRowDots[0]; // Leftmost dot on the next row

            // Draw wire from lastDot to firstDotNextRow with the specified path
            const verticalOffset = color === 'black' ? 25 : 20; // Black wires come down 5px more
            const horizontalOffset = 30; // Horizontal offset for direction changes
            drawWire([
              { x: lastDot.x, y: lastDot.y }, // Start at the last dot
              { x: lastDot.x, y: lastDot.y + verticalOffset + 20 }, // Go down (20px for red, 25px for black) + 20px more
              { x: firstDotNextRow.x - horizontalOffset, y: lastDot.y + verticalOffset + 20 }, // Go over 30px past the leftmost dot below
              { x: firstDotNextRow.x - horizontalOffset, y: firstDotNextRow.y + verticalOffset }, // Go down to the level of the next dot
              { x: firstDotNextRow.x, y: firstDotNextRow.y + verticalOffset }, // Go over to the first dot on the next row
              { x: firstDotNextRow.x, y: firstDotNextRow.y }, // Go up to the first dot on the next row
            ], color);
          }
        }
      }
    }
  });
}

// Function to draw a wire
function drawWire(path, color) {
  const svgNS = "http://www.w3.org/2000/svg";
  const polyline = document.createElementNS(svgNS, "polyline");

  // Format the points string
  const points = path.map((p) => `${p.x},${p.y}`).join(' ');
  polyline.setAttribute('points', points);
  polyline.setAttribute('stroke', color);
  polyline.setAttribute('fill', 'none');
  polyline.setAttribute('stroke-width', '2');

  // Append the polyline to the SVG container
  const wiringSvg = document.getElementById('wiring-svg');
  wiringSvg.appendChild(polyline);
}


// Wire Drawing Logic
const wiringSvg = document.getElementById('wiring-svg');
const wirePopup = document.getElementById('wire-popup');
const drawWiringButton = document.getElementById('draw-wiring');
const clearWiringButton = document.getElementById('clear-wiring');
let isDrawing = false;
let currentWireType = 'POWER'; // Default wire type
let wirePoints = []; // Stores the points of the current wire
let previewLine = null; // Preview line for the wire
let lastPoint = null; // Last point in the wire

// Show wire selection popup
drawWiringButton.addEventListener('click', () => {
  if (!isDrawing) {
    wirePopup.style.display = 'block';
  }
});

// Handle wire type selection
wirePopup.querySelectorAll('button').forEach((button) => {
  button.addEventListener('click', () => {
    currentWireType = button.getAttribute('data-type');
    wirePopup.style.display = 'none';
    startDrawing();
  });
});

// Start drawing a wire
function startDrawing() {
  isDrawing = true;
  wirePoints = [];
  lastPoint = null;
  wiringSvg.style.pointerEvents = 'all';
  wiringSvg.addEventListener('click', handleClick);
  document.addEventListener('keydown', handleKeyDown);
  wiringSvg.addEventListener('mousemove', handleMouseMove);
}

// Handle mouse clicks to add points
function handleClick(e) {
  const rect = wiringSvg.getBoundingClientRect();
  let x = e.clientX - rect.left;
  let y = e.clientY - rect.top;

  // Check if the click is near a dot
  const nearestDot = findNearestDot(x, y);
  if (nearestDot) {
    x = nearestDot.x;
    y = nearestDot.y;
  }

  if (!lastPoint) {
    // First click: start the wire
    wirePoints.push({ x, y });
    lastPoint = { x, y };
  } else {
    // Subsequent clicks: add a new point in 90-degree direction
    const dx = x - lastPoint.x;
    const dy = y - lastPoint.y;

    if (Math.abs(dx) > Math.abs(dy)) {
      // Horizontal movement
      wirePoints.push({ x, y: lastPoint.y });
    } else {
      // Vertical movement
      wirePoints.push({ x: lastPoint.x, y });
    }

    lastPoint = wirePoints[wirePoints.length - 1];
    drawWireSegment();
  }
}

// Handle keydown events (Enter to end wire, Ctrl+Z to undo, Ctrl+Y to redo)
function handleKeyDown(e) {
  if (e.key === 'Enter') {
    if (wirePoints.length > 1) {
      // Draw the final wire
      drawWireSegment();
      endDrawing();
    }
  } else if (e.ctrlKey && e.key === 'z') {
    undo();
  } else if (e.ctrlKey && e.key === 'y') {
    redo();
  }
}

// Handle mouse movement to show preview
function handleMouseMove(e) {
  if (!isDrawing || wirePoints.length === 0) return;

  const rect = wiringSvg.getBoundingClientRect();
  let x = e.clientX - rect.left;
  let y = e.clientY - rect.top;

  // Check if the mouse is near a dot
  const nearestDot = findNearestDot(x, y);
  if (nearestDot) {
    x = nearestDot.x;
    y = nearestDot.y;
  }

  // Remove existing preview line
  if (previewLine) {
    previewLine.remove();
  }

  // Draw preview line in 90-degree direction
  const lastPoint = wirePoints[wirePoints.length - 1];
  const dx = x - lastPoint.x;
  const dy = y - lastPoint.y;

  if (Math.abs(dx) > Math.abs(dy)) {
    // Horizontal preview
    previewLine = drawLine(lastPoint.x, lastPoint.y, x, lastPoint.y, currentWireType, true);
  } else {
    // Vertical preview
    previewLine = drawLine(lastPoint.x, lastPoint.y, lastPoint.x, y, currentWireType, true);
  }
}

// Draw a wire segment between the last two points
function drawWireSegment() {
  if (wirePoints.length < 2) return;

  const start = wirePoints[wirePoints.length - 2];
  const end = wirePoints[wirePoints.length - 1];
  drawLine(start.x, start.y, end.x, end.y, currentWireType);
}

// Draw a line between two points
function drawLine(x1, y1, x2, y2, type, isPreview = false) {
  const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  line.setAttribute('x1', x1);
  line.setAttribute('y1', y1);
  line.setAttribute('x2', x2);
  line.setAttribute('y2', y2);
  line.setAttribute('stroke', getWireColor(type));
  line.setAttribute('stroke-width', '6');

  if (type === 'DMX') {
    line.setAttribute('stroke-dasharray', '5,5');
  }

  if (isPreview) {
    line.setAttribute('stroke-opacity', '0.5');
  }

  wiringSvg.appendChild(line);
  return line;
}

// End drawing and reset state
function endDrawing() {
  isDrawing = false;
  wirePoints = [];
  lastPoint = null;
  wiringSvg.removeEventListener('click', handleClick);
  document.removeEventListener('keydown', handleKeyDown);
  wiringSvg.removeEventListener('mousemove', handleMouseMove);

  // Remove preview line
  if (previewLine) {
    previewLine.remove();
    previewLine = null;
  }

  // Wait 2 seconds before allowing the next wire run
  setTimeout(() => {
    wiringSvg.style.pointerEvents = 'none';
  }, 2000);
}

// Get wire color based on type
function getWireColor(type) {
  switch (type) {
    case 'CRESNET': return 'green';
    case 'ETHERNET': return 'blue';
    case 'ZUMNET': return 'purple';
    case 'ZUMLINK': return 'orange';
    case 'POWER': return 'black';
    case 'DMX': return 'url(#rainbow)';
    default: return 'black';
  }
}

// Clear all wires
clearWiringButton.addEventListener('click', () => {
  wiringSvg.innerHTML = '';
  // Re-add the gradient definition for DMX wires
  wiringSvg.appendChild(defs);
});

// Add rainbow gradient for DMX wires
const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
gradient.setAttribute('id', 'rainbow');
gradient.setAttribute('x1', '0%');
gradient.setAttribute('y1', '0%');
gradient.setAttribute('x2', '100%');
gradient.setAttribute('y2', '0%');
gradient.innerHTML = `
  <stop offset="0%" style="stop-color:red;stop-opacity:1" />
  <stop offset="16.67%" style="stop-color:orange;stop-opacity:1" />
  <stop offset="33.33%" style="stop-color:yellow;stop-opacity:1" />
  <stop offset="50%" style="stop-color:green;stop-opacity:1" />
  <stop offset="66.67%" style="stop-color:blue;stop-opacity:1" />
  <stop offset="83.33%" style="stop-color:indigo;stop-opacity:1" />
  <stop offset="100%" style="stop-color:violet;stop-opacity:1" />
`;
defs.appendChild(gradient);
wiringSvg.appendChild(defs);

// Function to find the nearest dot
function findNearestDot(x, y) {
  let nearestDot = null;
  let minDistance = Infinity;
  const threshold = 0; // Distance threshold for snapping (in pixels)

  // Loop through all parts and their dots
  document.querySelectorAll('.part').forEach((part) => {
    const partRect = part.getBoundingClientRect();
    const dots = part.querySelectorAll('.dot');

    dots.forEach((dot) => {
      const dotRect = dot.getBoundingClientRect();
      const dotCenterX = dotRect.left + dotRect.width / 2 - partRect.left;
      const dotCenterY = dotRect.top + dotRect.height / 2 - partRect.top;

      // Calculate distance between wire endpoint and dot center
      const distance = Math.sqrt((x - dotCenterX) ** 2 + (y - dotCenterY) ** 2);

      // Check if this dot is the nearest
      if (distance < threshold && distance < minDistance) {
        minDistance = distance;
        nearestDot = { x: dotCenterX, y: dotCenterY };
      }
    });
  });

  return nearestDot;
}

// Undo functionality
let undoStack = [];
let redoStack = [];

function undo() {
  if (undoStack.length > 0) {
    const lastWire = undoStack.pop();
    redoStack.push(lastWire);
    lastWire.remove();
  }
}

// Redo functionality
function redo() {
  if (redoStack.length > 0) {
    const lastWire = redoStack.pop();
    undoStack.push(lastWire);
    wiringSvg.appendChild(lastWire);
  }
}
  </script>
</body>
</html>

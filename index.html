<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Panel Builder</title>
  <style>
    /* General Styles */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f8f9fa; /* Light gray background */
      color: #333; /* Dark gray text */
    }

    /* Tabs */
    .tabs {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
      background-color: #ffffff; /* White background */
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Subtle shadow */
      border-radius: 8px;
      padding: 10px;
    }

    .tab {
      padding: 10px 20px;
      cursor: pointer;
      background-color: #e9ecef; /* Light gray */
      margin: 0 5px;
      border-radius: 5px;
      color: #333; /* Dark gray text */
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    .tab.active {
      background-color: #007bff; /* Crestron blue */
      color: #ffffff; /* White text */
    }

    .tab:hover {
      background-color: #0056b3; /* Darker blue on hover */
      color: #ffffff; /* White text */
    }

    /* Content */
    .content {
      display: none;
      width: 100%;
      max-width: 1200px;
      background-color: #ffffff; /* White background */
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Subtle shadow */
    }

    .content.active {
      display: block;
    }

    /* Panel Builder */
    .panel-builder {
      display: flex;
      gap: 20px; /* Add spacing between toolbar and grid */
    }

    .toolbar {
      width: 200px;
      background-color: #ffffff; /* White background */
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Subtle shadow */
    }

    .toolbar button {
      display: block;
      width: 100%;
      margin-bottom: 10px;
      padding: 10px;
      cursor: pointer;
      background-color: #007bff; /* Crestron blue */
      color: #ffffff; /* White text */
      border: none;
      border-radius: 5px;
      transition: background-color 0.3s ease;
    }

    .toolbar button:hover {
      background-color: #0056b3; /* Darker blue on hover */
    }

    .toolbar select {
      width: 100%;
      padding: 10px;
      margin-bottom: 10px;
      border: 1px solid #ced4da; /* Light gray border */
      border-radius: 5px;
      background-color: #ffffff; /* White background */
      color: #333; /* Dark gray text */
    }

    .grid {
      flex: 1;
      position: relative;
      height: 2500px;
      border: 1px solid #ced4da; /* Light gray border */
      background-color: #ffffff; /* White background */
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Subtle shadow */
    }

    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent black */
    }

    .modal-content {
      background-color: #ffffff; /* White background */
      margin: 15% auto;
      padding: 20px;
      border: 1px solid #ced4da; /* Light gray border */
      width: 50%;
      max-width: 600px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Subtle shadow */
    }

    .close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }

    .close:hover,
    .close:focus {
      color: #333; /* Dark gray text */
    }

    /* Part Colors */
    .part-zumnet {
      fill: #6f42c1; /* Purple */
    }

    .part-zumlink {
      fill: #fd7e14; /* Orange */
    }

    .part-psu {
      fill: #6c757d; /* Gray */
    }

    .part-other {
      fill: #343a40; /* Dark gray */
    }

    .part-multi {
      fill: #ffffff; /* White */
      stroke: #333; /* Dark gray border */
    }

    /* Wire Styles */
    .wire {
      cursor: pointer;
    }

    .wire.selected {
      stroke-width: 4; /* Highlight selected wire */
    }

    .wire-net {
      stroke: #6f42c1; /* Purple */
    }

    .wire-link {
      stroke: #fd7e14; /* Orange */
    }

    .wire-red {
      stroke: #dc3545; /* Red */
    }

    /* Dashed Line Style */
    .dashed-line {
      stroke: #6c757d; /* Gray */
      stroke-width: 1;
      stroke-dasharray: 5,5;
    }
	
	.dragging {
  opacity: 0.7;
  cursor: grabbing;
}
  </style>
</head>
<!-- Include jsPDF and html2canvas libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>
  <div class="tabs">
    <div class="tab active" onclick="switchTab('panel-builder')">Panel Builder</div>
    <div class="tab" onclick="switchTab('panel-wiring')">Panel Wiring</div>
    <div class="tab" onclick="switchTab('space-layout')">Space Layout</div>
    <div class="tab" onclick="switchTab('load-schedule')">Load Schedule</div>
  </div>

  <div id="panel-builder" class="content active">
    <div class="panel-builder">
      <div class="toolbar">
        <select id="panel-size">
          <option value="none">None</option>
          <option value="DIN-EN-2X18">DIN-EN-2X18</option>
          <option value="DIN-EN-3X18">DIN-EN-3X18</option>
          <option value="DIN-EN-6X18">DIN-EN-6X18</option>
          <option value="DIN-EN-10X18">DIN-EN-10X18</option>
        </select>
        <button onclick="addPart('ZUMNET-DIN-DLI')">ZUMNET-DIN-DLI</button>
        <button onclick="addPart('ZUMNET-DIN-16A-LV')">ZUMNET-DIN-16A-LV</button>
        <button onclick="addPart('ZUMLINK-DIN-PSU')">ZUMLINK-DIN-PSU</button>
        <button onclick="addPart('ZUMLINK-DIN-16A-LV')">ZUMLINK-DIN-16A-LV</button>
        <button onclick="addPart('ZUMLINK-DIN-20A-SW')">ZUMLINK-DIN-20A-SW</button>
        <button onclick="addPart('ZUMLINK-DIN-20A-PLUG')">ZUMLINK-DIN-20A-PLUG</button>
        <button onclick="addPart('ZUMLINK-DIN-DIMU')">ZUMLINK-DIN-DIMU</button>
        <button onclick="addPart('ZUMLINK-DIN-IO')">ZUMLINK-DIN-IO</button>
        <button onclick="addPart('DIN-DMX')">DIN-DMX</button>
        <button onclick="addPart('ZUM-HUB4')">ZUM-HUB4</button>
        <button onclick="addPart('CEN-SWPOE-5AC')">CEN-SWPOE-5AC</button>
        <button onclick="addPart('DIN-AP4')">DIN-AP4</button>
        <button onclick="addPart('DIN-PWS60')">DIN-PWS60</button>
        <button onclick="addPart('DIN-DALI-2')">DIN-DALI-2</button>
        <button onclick="addPart('TERMINAL RAIL')">TERMINAL RAIL</button>
        <button onclick="printPDF()">Print PDF</button> <!-- Add Print PDF button -->
        <button onclick="importJSON()">IMPORT</button>
      </div>
      <div class="grid" id="grid">
        <svg id="svg-grid" width="600" height="2000"></svg>
      </div>
    </div>
  </div>

  <div id="panel-wiring" class="content">
    <h2>Panel Wiring</h2>
  </div>

  <div id="space-layout" class="content">
    <h2>Space Layout</h2>
    <table id="space-layout-chart">
      <thead>
        <tr>
          <th>Space Name</th>
          <th>Load Controllers</th>
          <th>Zone</th>
          <th>Device mA</th>
          <th>Lighting Load</th>
        </tr>
      </thead>
      <tbody>
        <!-- Rows will be dynamically populated here -->
      </tbody>
    </table>
  </div>

  <div id="load-schedule" class="content">
    <h2>Load Schedule</h2>
  </div>

  <!-- Modal for part details -->
  <div id="part-modal" class="modal">
    <div class="modal-content">
      <span class="close">&times;</span>
      <h2>Part Details</h2>
      <form id="part-form">
        <label for="space-number">Space Number:</label>
        <input type="number" id="space-number" name="space-number" required><br><br>
        <label for="space-name">Space Name:</label>
        <input type="text" id="space-name" name="space-name"><br><br>
        <label for="zone">Zone:</label>
        <input type="text" id="zone" name="zone"><br><br>
        <label for="voltage">Voltage:</label>
        <select id="voltage" name="voltage">
          <option value="120">120</option>
          <option value="277">277</option>
        </select><br><br>
        <label for="lighting-load">Lighting Load:</label>
        <input type="number" id="lighting-load" name="lighting-load"><br><br>
        <label for="device-mA">Device mA:</label>
        <input type="number" id="device-mA" name="device-mA"><br><br>
        <button type="submit">Save</button>
      </form>
    </div>
  </div>

  <script>
const parts = {
  'ZUMNET-DIN-DLI': { width: 71, height: 94, class: 'part-zumnet', fill: '#6f42c1' }, // Purple
  'ZUMNET-DIN-16A-LV': { width: 71, height: 94, class: 'part-zumnet', fill: '#6f42c1' }, // Purple
  'ZUMLINK-DIN-PSU': { width: 71, height: 94, class: 'part-psu', fill: '#6c757d' }, // Gray
  'ZUMLINK-DIN-16A-LV': { width: 53, height: 94, class: 'part-zumlink', fill: '#fd7e14' }, // Orange
  'ZUMLINK-DIN-20A-SW': { width: 53, height: 94, class: 'part-zumlink', fill: '#fd7e14' }, // Orange
  'ZUMLINK-DIN-20A-PLUG': { width: 53, height: 94, class: 'part-zumlink', fill: '#fd7e14' }, // Orange
  'ZUMLINK-DIN-DIMU': { width: 53, height: 94, class: 'part-zumlink', fill: '#fd7e14' }, // Orange
  'ZUMLINK-DIN-IO': { width: 71, height: 94, class: 'part-zumlink', fill: '#fd7e14' }, // Orange
  'DIN-DMX': { width: 144, height: 90, class: 'part-other', fill: '#343a40' }, // Dark gray
  'ZUM-HUB4': { width: 165, height: 439, class: 'part-other', fill: '#343a40' }, // Dark gray
  'CEN-SWPOE-5AC': { width: 187, height: 120, class: 'part-other', fill: '#343a40' }, // Dark gray
  'DIN-AP4': { width: 161, height: 91, class: 'part-other', fill: '#343a40' }, // Dark gray
  'DIN-PWS60': { width: 108, height: 94, class: 'part-other', fill: '#343a40' }, // Dark gray
  'DIN-DALI-2': { width: 159, height: 95, class: 'part-other', fill: '#343a40' }, // Dark gray
  'TERMINAL RAIL': { width: 80, height: 50, class: 'part-multi', fill: '#ffffff' }, // White
};

const partAbbreviations = {
  'ZUMNET-DIN-DLI': 'DLI',
  'ZUMNET-DIN-16A-LV': 'N-LV',
  'ZUMLINK-DIN-16A-LV': 'L-LV',
  'ZUMLINK-DIN-DIMU': 'L-DIMU',
  'ZUMLINK-DIN-20A-SW': 'L-SW',
  'ZUMLINK-DIN-20A-PLUG': 'L-PLUG',
  'ZUMLINK-DIN-PSU': 'PSU',
  'ZUMLINK-DIN-IO': 'L-IO'
};

const panelSizes = {
  'DIN-EN-2X18': { rails: 2, width: 424, height: 323 },
  'DIN-EN-3X18': { rails: 3, width: 424, height: 597 },
  'DIN-EN-6X18': { rails: 6, width: 424, height: 989 },
  'DIN-EN-10X18': { rails: 10, width: 424, height: 1594 }
};

let currentPanel = null;
let currentRails = [];
let zumnetCounter = 1;
let lastZumnetNumber = 0;
let partDataMap = new Map(); // Store part data

const svgGrid = document.getElementById('svg-grid');
const panelSizeSelect = document.getElementById('panel-size');

panelSizeSelect.addEventListener('change', () => {
  const selectedSize = panelSizeSelect.value;
  if (selectedSize === 'none') {
    clearPanel();
  } else {
    createPanel(selectedSize);
  }
});

function switchTab(tabName) {
  document.querySelectorAll('.content').forEach(content => content.classList.remove('active'));
  document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
  document.getElementById(tabName).classList.add('active');
  document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
}

function createPanel(size) {
  clearPanel();
  const panelData = panelSizes[size];
  const panelWidth = panelData.width;
  const panelHeight = panelData.height;
  const railCount = panelData.rails;

  const panelX = (500 - panelWidth) / 2;
  const panelY = (2000 - panelHeight) / 2;

  currentPanel = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  currentPanel.setAttribute('x', panelX);
  currentPanel.setAttribute('y', panelY);
  currentPanel.setAttribute('width', panelWidth);
  currentPanel.setAttribute('height', panelHeight);
  currentPanel.setAttribute('fill', 'grey');
  svgGrid.appendChild(currentPanel);

  const railSpacing = (panelHeight - (railCount * 18)) / (railCount + 1);
  for (let i = 0; i < railCount; i++) {
    const railY = panelY + railSpacing * (i + 1) + 18 * i;
    const rail = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rail.setAttribute('x', panelX + (panelWidth - 324) / 2);
    rail.setAttribute('y', railY);
    rail.setAttribute('width', 324);
    rail.setAttribute('height', 18);
    rail.setAttribute('fill', '#ccc');
    svgGrid.appendChild(rail);
    currentRails.push({ rail, parts: [], totalWidth: 0 });
  }

  // Add dashed vertical line where the rails begin
  const dashedLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  dashedLine.setAttribute('x1', panelX + (panelWidth - 324) / 2);
  dashedLine.setAttribute('y1', panelY);
  dashedLine.setAttribute('x2', panelX + (panelWidth - 324) / 2);
  dashedLine.setAttribute('y2', panelY + panelHeight);
  dashedLine.setAttribute('class', 'dashed-line');
  svgGrid.appendChild(dashedLine);
}

function clearPanel() {
  svgGrid.innerHTML = '';
  currentPanel = null;
  currentRails = [];
  zumnetCounter = 1;
  lastZumnetNumber = 0;
  partDataMap.clear();
}

function addPart(partName) {
  if (!currentPanel) return;

  const partData = parts[partName];
  const partWidth = partData.width;
  const partHeight = partData.height;
  const partClass = partData.class;

  // Find the last rail that has parts added to it
  let targetRailIndex = -1;
  for (let i = currentRails.length - 1; i >= 0; i--) {
    const rail = currentRails[i];
    if (rail.parts.length > 0) {
      targetRailIndex = i;
      break;
    }
  }

  // If no rail has parts yet, use the first rail
  if (targetRailIndex === -1) {
    targetRailIndex = 0;
  }

  // Check if the part can fit on the current rail
  let targetRail = currentRails[targetRailIndex];
  if (targetRail.totalWidth + partWidth > 324) {
    // Part cannot fit on the current rail, try the next rail
    targetRailIndex++;
    if (targetRailIndex >= currentRails.length) {
      alert('No space available on any rail for the part.');
      return;
    }
    targetRail = currentRails[targetRailIndex];
  }

  // Calculate the position for the new part
  const partX = parseFloat(targetRail.rail.getAttribute('x')) + targetRail.totalWidth;
  const partY = parseFloat(targetRail.rail.getAttribute('y')) - partHeight + 18;

  // Create the part rectangle
  const partRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  partRect.setAttribute('x', partX);
  partRect.setAttribute('y', partY);
  partRect.setAttribute('width', partWidth);
  partRect.setAttribute('height', partHeight);
  partRect.setAttribute('class', partClass);
  partRect.setAttribute('stroke', 'black');
  partRect.setAttribute('stroke-width', '1');
  partRect.setAttribute('data-part-id', Date.now()); // Unique ID for each part
  partRect.setAttribute('data-part-name', partName); // Add part name for identification
  svgGrid.appendChild(partRect);

  // Add drag-and-drop listeners
  addDragAndDropListeners(partRect);

  // Add part number text
  const partNumber = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  partNumber.setAttribute('x', partX + 5);
  partNumber.setAttribute('y', partY + 15);
  partNumber.setAttribute('fill', 'black');
  partNumber.setAttribute('font-size', '12');
  if (partName.startsWith('ZUMNET')) {
    partNumber.textContent = zumnetCounter;
    lastZumnetNumber = zumnetCounter;
    zumnetCounter++;
  } else if (partName.startsWith('ZUMLINK') && partName !== 'ZUMLINK-DIN-PSU') {
    partNumber.textContent = lastZumnetNumber;
  } else {
    partNumber.textContent = '';
  }
  svgGrid.appendChild(partNumber);

  // Add abbreviated part name text
  const partAbbreviation = partAbbreviations[partName];
  if (partAbbreviation) {
    const partNameText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    partNameText.setAttribute('x', partX + 5);
    partNameText.setAttribute('y', partY + 30);
    partNameText.setAttribute('fill', 'black');
    partNameText.setAttribute('font-size', '12');
    partNameText.textContent = partAbbreviation;
    svgGrid.appendChild(partNameText);
  }

  // Add the part to the rail and update the total width
  targetRail.parts.push(partRect);
  targetRail.totalWidth += partWidth;

  // Add double-click event listener to the part
  partRect.addEventListener('dblclick', () => {
    openModal(partRect, partNumber);
  });

  // Reconnect wires after adding the part
  connectZumnetParts();
  if (partName.startsWith('ZUMLINK') && partName !== 'ZUMLINK-DIN-PSU') {
    connectZumlinkParts();
  } else if (partName.startsWith('ZUMNET')) {
    // If a new ZUMNET is added, reset the ZUMLINK wiring
    connectZumlinkParts();
    connectPSUParts();
  }
}

function connectZumnetParts() {
  // Remove all existing ZUMNET wires
  svgGrid.querySelectorAll('.wire-net').forEach(wire => wire.remove());

  // Get all ZUMNET parts and sort them by rail and X position
  const zumnetParts = Array.from(svgGrid.querySelectorAll('.part-zumnet'));
  zumnetParts.sort((a, b) => {
    const aY = parseFloat(a.getAttribute('y'));
    const bY = parseFloat(b.getAttribute('y'));
    if (aY !== bY) return aY - bY; // Sort by Y position (rail)
    return parseFloat(a.getAttribute('x')) - parseFloat(b.getAttribute('x')); // Sort by X position (left to right)
  });

  // Connect ZUMNET parts
  for (let i = 0; i < zumnetParts.length - 1; i++) {
    const part1 = zumnetParts[i];
    const part2 = zumnetParts[i + 1];

    const part1X = parseFloat(part1.getAttribute('x'));
    const part1Y = parseFloat(part1.getAttribute('y')) + parseFloat(part1.getAttribute('height'));
    const part1Width = parseFloat(part1.getAttribute('width'));

    const part2X = parseFloat(part2.getAttribute('x'));
    const part2Y = parseFloat(part2.getAttribute('y')) + parseFloat(part2.getAttribute('height'));
    const part2Width = parseFloat(part2.getAttribute('width'));

    // Check if parts are on the same rail
    const isSameRail = Math.abs(part1Y - part2Y) < 5; // Allow for small floating-point differences

    if (isSameRail) {
      // Wire on the same rail (left to right)
      const wire = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      wire.setAttribute('d', `
        M ${part1X + 20} ${part1Y}
        V ${part1Y + 10}
        H ${part2X + 10}
        V ${part2Y}
      `);
      wire.setAttribute('stroke', '#6f42c1'); // Purple
      wire.setAttribute('stroke-width', '2');
      wire.setAttribute('fill', 'none');
      wire.setAttribute('class', 'wire-net');
      svgGrid.appendChild(wire);
    } else {
      // Wire between rails (down to the next rail and continue left to right)
      const railX = parseFloat(currentRails[0].rail.getAttribute('x')); // X-coordinate of the rail

      // Wire from part1 (last ZUMNET on the current rail) to part2 (first ZUMNET on the next rail)
      const wire = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      wire.setAttribute('d', `
        M ${part1X + 20} ${part1Y}
        V ${part1Y + 20}
        H ${railX - 55}
        V ${part2Y + 10}
        H ${part2X + 10}
        V ${part2Y}
      `);
      wire.setAttribute('stroke', '#6f42c1'); // Purple
      wire.setAttribute('stroke-width', '2');
      wire.setAttribute('fill', 'none');
      wire.setAttribute('class', 'wire-net');
      svgGrid.appendChild(wire);
    }
  }
}

function connectZumlinkParts() {
  const zumnetParts = Array.from(svgGrid.querySelectorAll('.part-zumnet'));
  const zumlinkParts = Array.from(svgGrid.querySelectorAll('.part-zumlink:not(.part-psu)')); // Exclude PSU

  // Group parts into ZUMNET + ZUMLINK groups
  const groups = [];
  let currentGroup = [];

  for (const part of [...zumnetParts, ...zumlinkParts].sort((a, b) => {
    const aY = parseFloat(a.getAttribute('y'));
    const bY = parseFloat(b.getAttribute('y'));
    if (aY !== bY) return aY - bY; // Sort by Y position (rail)
    return parseFloat(a.getAttribute('x')) - parseFloat(b.getAttribute('x')); // Sort by X position
  })) {
    if (part.classList.contains('part-zumnet')) {
      // Start a new group when a ZUMNET is encountered
      if (currentGroup.length > 0) groups.push(currentGroup);
      currentGroup = [part]; // Start with the ZUMNET
    } else if (part.classList.contains('part-zumlink')) {
      // Add ZUMLINK parts to the current group
      currentGroup.push(part);
    }
  }

  // Add the last group if it exists
  if (currentGroup.length > 0) groups.push(currentGroup);

  // Connect parts within each group
  for (const group of groups) {
    if (group.length < 2) continue; // Skip groups with only a ZUMNET

    const zumnet = group[0]; // First part is the ZUMNET
    const zumlinks = group.slice(1); // Remaining parts are ZUMLINKs

    // Connect ZUMNET to the first ZUMLINK
    const zumnetX = parseFloat(zumnet.getAttribute('x'));
    const zumnetY = parseFloat(zumnet.getAttribute('y')) + parseFloat(zumnet.getAttribute('height'));
    const zumnetWidth = parseFloat(zumnet.getAttribute('width'));

    const firstZumlink = zumlinks[0];
    const firstZumlinkX = parseFloat(firstZumlink.getAttribute('x'));
    const firstZumlinkY = parseFloat(firstZumlink.getAttribute('y')) + parseFloat(firstZumlink.getAttribute('height'));
    const firstZumlinkWidth = parseFloat(firstZumlink.getAttribute('width'));

    // Check if ZUMNET and ZUMLINK are on the same rail
    const isSameRail = Math.abs(zumnetY - firstZumlinkY) < 5; // Allow for small floating-point differences

    if (isSameRail) {
      // Wire from ZUMNET to the first ZUMLINK on the same rail
      const wire1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      wire1.setAttribute('d', `
        M ${zumnetX + zumnetWidth - 10} ${zumnetY}
        V ${zumnetY + 30}
        H ${firstZumlinkX + 10}
        V ${firstZumlinkY}
      `);
      wire1.setAttribute('stroke', '#fd7e14'); // Orange
      wire1.setAttribute('stroke-width', '2');
      wire1.setAttribute('fill', 'none');
      wire1.setAttribute('class', 'wire-link');
      svgGrid.appendChild(wire1);
    } else {
      // Wire from ZUMNET to the first ZUMLINK on another rail
      const railX = parseFloat(currentRails[0].rail.getAttribute('x')); // X-coordinate of the rail

      const wire1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      wire1.setAttribute('d', `
        M ${zumnetX + zumnetWidth - 10} ${zumnetY}
        V ${zumnetY + 43}
        H ${railX - 45}
        V ${firstZumlinkY + 35}
        H ${firstZumlinkX + 10}
        V ${firstZumlinkY}
      `);
      wire1.setAttribute('stroke', '#fd7e14'); // Orange
      wire1.setAttribute('stroke-width', '2');
      wire1.setAttribute('fill', 'none');
      wire1.setAttribute('class', 'wire-link');
      svgGrid.appendChild(wire1);
    }

    // Connect subsequent ZUMLINK parts
    for (let i = 0; i < zumlinks.length - 1; i++) {
      const part1 = zumlinks[i];
      const part2 = zumlinks[i + 1];

      const part1X = parseFloat(part1.getAttribute('x'));
      const part1Y = parseFloat(part1.getAttribute('y')) + parseFloat(part1.getAttribute('height'));
      const part1Width = parseFloat(part1.getAttribute('width'));

      const part2X = parseFloat(part2.getAttribute('x'));
      const part2Y = parseFloat(part2.getAttribute('y')) + parseFloat(part2.getAttribute('height'));
      const part2Width = parseFloat(part2.getAttribute('width'));

      // Check if parts are on the same rail
      const isSameRail = Math.abs(part1Y - part2Y) < 5; // Allow for small floating-point differences

      if (isSameRail) {
        // Wire on the same rail
        const wire = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        wire.setAttribute('d', `
          M ${part1X + part1Width - 10} ${part1Y}
          V ${part1Y + 30}
          H ${part2X + 10}
          V ${part2Y}
        `);
        wire.setAttribute('stroke', '#fd7e14'); // Orange
        wire.setAttribute('stroke-width', '2');
        wire.setAttribute('fill', 'none');
        wire.setAttribute('class', 'wire-link');
        svgGrid.appendChild(wire);
      } else {
        // Wire between rails
        const railX = parseFloat(currentRails[0].rail.getAttribute('x')); // X-coordinate of the rail
        const widthFromPartToRail = part1X + part1Width - railX; // Width from part to beginning of rail

        const wire = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        wire.setAttribute('d', `
          M ${part1X + part1Width - 10} ${part1Y}
          V ${part1Y + 43}
          H ${railX - 45}
          V ${part2Y + 35}
          H ${part2X + 10}
          V ${part2Y}
        `);
        wire.setAttribute('stroke', '#fd7e14'); // Orange
        wire.setAttribute('stroke-width', '2');
        wire.setAttribute('fill', 'none');
        wire.setAttribute('class', 'wire-link');
        svgGrid.appendChild(wire);
      }
    }
  }
}

function connectPSUParts() {
  // Remove all existing PSU wires and wire numbers
  clearPSUWires();

  // Define wire colors for each PSU
  const wireColors = ['#dc3545', '#000000', '#007bff', '#28a745']; // Red, Black, Blue, Green

  // Get all PSU parts and sort them by Y position (rail)
  const psuParts = Array.from(svgGrid.querySelectorAll('.part-psu'));
  psuParts.sort((a, b) => {
    const aY = parseFloat(a.getAttribute('y'));
    const bY = parseFloat(b.getAttribute('y'));
    return aY - bY; // Sort by Y position (rail)
  });

  // Get all ZUMNET parts and sort them by Y position (rail) and X position (left to right)
  const zumnetParts = Array.from(svgGrid.querySelectorAll('.part-zumnet'));
  zumnetParts.sort((a, b) => {
    const aY = parseFloat(a.getAttribute('y'));
    const bY = parseFloat(b.getAttribute('y'));
    if (aY !== bY) return aY - bY; // Sort by Y position (rail)
    return parseFloat(a.getAttribute('x')) - parseFloat(b.getAttribute('x')); // Sort by X position (left to right)
  });

  // Connect each PSU to 4 ZUMNET parts
  psuParts.forEach((psu, psuIndex) => {
    const psuX = parseFloat(psu.getAttribute('x'));
    const psuY = parseFloat(psu.getAttribute('y')) + parseFloat(psu.getAttribute('height'));
    const psuWidth = parseFloat(psu.getAttribute('width'));

    // Calculate the starting index for ZUMNET parts (4 per PSU)
    const startIndex = psuIndex * 4;
    const endIndex = startIndex + 4;

    // Get the 4 ZUMNET parts for this PSU
    const zumnetsForPSU = zumnetParts.slice(startIndex, endIndex);

    // Define the vertical offsets for the wires (55px, 50px, 45px, 40px)
    const wireOffsets = [55, 50, 45, 40];

    // Get the wire color for this PSU
    const wireColor = wireColors[psuIndex % wireColors.length]; // Cycle through colors if there are more PSUs than colors

    // Connect each of the 4 wires from the PSU to the ZUMNET parts
    zumnetsForPSU.forEach((zumnet, wireIndex) => {
      const zumnetX = parseFloat(zumnet.getAttribute('x'));
      const zumnetY = parseFloat(zumnet.getAttribute('y')) + parseFloat(zumnet.getAttribute('height'));
      const zumnetWidth = parseFloat(zumnet.getAttribute('width'));

      // Calculate the horizontal spacing between wires (20px apart for better spacing)
      const wireSpacing = 20;
      const wireHorizontalOffset = wireIndex * wireSpacing;

      // Calculate the vertical offset for this wire
      const wireVerticalOffset = wireOffsets[wireIndex];

      // Calculate the connection point on the ZUMNET (15px from the right)
      const zumnetConnectionX = zumnetX + zumnetWidth - 15;

      // Check if the ZUMNET is on a row below the PSU
      const isZumnetBelow = zumnetY > psuY;

      // Calculate the distance from the PSU to the right side of the rail
      const railX = parseFloat(currentRails[0].rail.getAttribute('x'));
      const railWidth = 324; // Width of the rail
      const distanceToRightSide = railX + railWidth - (psuX + psuWidth);

      // Additional spacing for wires going to a different row (5px per wire)
      const additionalSpacing = wireIndex * 5;

      // Wire from PSU to ZUMNET
      const wire = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      if (isZumnetBelow) {
        // Path for ZUMNET on a row below: over to the right, down, over to the left, up
        wire.setAttribute('d', `
          M ${psuX + psuWidth / 2 - 30 + wireHorizontalOffset} ${psuY}
          V ${psuY + wireVerticalOffset}
          H ${psuX + psuWidth + distanceToRightSide + 40 + additionalSpacing}
          V ${zumnetY + wireVerticalOffset}
          H ${zumnetConnectionX}
          V ${zumnetY}
        `);
      } else {
        // Path for ZUMNET on the same row or above: straight to the ZUMNET
        wire.setAttribute('d', `
          M ${psuX + psuWidth / 2 - 30 + wireHorizontalOffset} ${psuY}
          V ${psuY + wireVerticalOffset}
          H ${zumnetConnectionX}
          V ${zumnetY}
        `);
      }
      wire.setAttribute('stroke', wireColor); // Use the assigned wire color
      wire.setAttribute('stroke-width', '2');
      wire.setAttribute('fill', 'none');
      wire.setAttribute('class', `wire-psu wire-${wireColor.replace('#', '')}`); // Add a common class for PSU wires
      wire.setAttribute('data-zumnet-id', zumnet.getAttribute('data-part-id')); // Store the ZUMNET ID for tracking
      svgGrid.appendChild(wire);

      // Add wire number above the wire on the PSU
      const psuWireNumber = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      psuWireNumber.setAttribute('x', psuX + psuWidth / 2 - 30 + wireHorizontalOffset);
      psuWireNumber.setAttribute('y', psuY - 10); // Position above the wire on the PSU
      psuWireNumber.setAttribute('fill', wireColor); // Use the same color as the wire
      psuWireNumber.setAttribute('font-size', '12');
      psuWireNumber.setAttribute('text-anchor', 'middle');
      psuWireNumber.setAttribute('class', 'wire-number');
      psuWireNumber.textContent = wireIndex + 1; // Assign wire number (1, 2, 3, 4)
      svgGrid.appendChild(psuWireNumber);

      // Add wire number above the wire on the ZUMNET
      const zumnetWireNumber = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      zumnetWireNumber.setAttribute('x', zumnetConnectionX);
      zumnetWireNumber.setAttribute('y', zumnetY - 10); // Position above the wire on the ZUMNET
      zumnetWireNumber.setAttribute('fill', wireColor); // Use the same color as the wire
      zumnetWireNumber.setAttribute('font-size', '12');
      zumnetWireNumber.setAttribute('text-anchor', 'middle');
      zumnetWireNumber.setAttribute('class', 'wire-number');
      zumnetWireNumber.textContent = wireIndex + 1; // Assign wire number (1, 2, 3, 4)
      svgGrid.appendChild(zumnetWireNumber);
    });
  });
}

function clearPSUWires() {
  console.log("Clearing all PSU wires...");

  // Remove all PSU wires and wire numbers
  const psuWires = svgGrid.querySelectorAll('.wire-psu, .wire-number');
  console.log(`Found ${psuWires.length} PSU wires to remove.`); // Debug log

  psuWires.forEach(wire => {
    console.log(`Removing wire: ${wire.getAttribute('class')}`); // Debug log
    wire.remove();
  });

  console.log("All PSU wires cleared."); // Debug log
}

function clearAllWires() {
  console.log("Clearing all wires...");

  // Remove all wires and wire numbers
  const wires = svgGrid.querySelectorAll('.wire-net, .wire-link, .wire-psu, .wire-number');
  console.log(`Found ${wires.length} wires to remove.`); // Debug log

  wires.forEach(wire => {
    console.log(`Removing wire: ${wire.getAttribute('class')}`); // Debug log
    wire.remove();
  });

  console.log("All wires cleared."); // Debug log
}

function redrawAllWires() {
  console.log("Redrawing all wires...");

  // Reconnect ZUMNET parts
  connectZumnetParts();

  // Reconnect ZUMLINK parts
  connectZumlinkParts();

  // Reconnect PSU parts
  connectPSUParts();

  console.log("All wires redrawn."); // Debug log
}

function addDragAndDropListeners(partRect) {
  let isDragging = false;
  let draggedPart = null;
  let draggedPartOffsetX = 0;
  let draggedPartOffsetY = 0;

  // Helper function to get the correct event coordinates (for both mouse and touch events)
  function getEventCoordinates(event) {
    if (event.touches) {
      // Touch event
      const touch = event.touches[0];
      return {
        x: touch.clientX,
        y: touch.clientY,
      };
    } else {
      // Mouse event
      return {
        x: event.clientX,
        y: event.clientY,
      };
    }
  }

  // Start dragging (for both mouse and touch events)
  function startDrag(event) {
    event.preventDefault();
    isDragging = true;
    draggedPart = partRect;

    // Get the initial offset between the mouse/touch position and the part's position
    const coords = getEventCoordinates(event);
    const partX = parseFloat(partRect.getAttribute('x'));
    const partY = parseFloat(partRect.getAttribute('y'));
    draggedPartOffsetX = coords.x - partX;
    draggedPartOffsetY = coords.y - partY;

    // Add dragging class for visual feedback
    partRect.classList.add('dragging');

    // Clear all wires when any part is dragged
    clearAllWires();
  }

  // Move the part (for both mouse and touch events)
  function drag(event) {
    if (!isDragging || !draggedPart) return;

    const coords = getEventCoordinates(event);

    // Calculate the new position of the part
    const newX = coords.x - draggedPartOffsetX;
    const newY = coords.y - draggedPartOffsetY;

    // Snap the part to the nearest rail and other parts
    const snappedPosition = snapToRailsAndParts(newX, newY, draggedPart);

    // Update the part's position
    draggedPart.setAttribute('x', snappedPosition.x);
    draggedPart.setAttribute('y', snappedPosition.y);

    // Update the positions of the associated text
    updatePartText(draggedPart, snappedPosition);

    // Show only the wire connected to the dragged part
    showWireForDraggedPart(draggedPart, snappedPosition);
  }

  // Stop dragging (for both mouse and touch events)
  function stopDrag() {
    if (!isDragging || !draggedPart) return;

    isDragging = false;
    draggedPart = null;

    // Remove dragging class
    partRect.classList.remove('dragging');

    // Redraw all wires after a 5-second delay
    setTimeout(() => {
      redrawAllWires(); // Redraw all wires
    }, 5000); // 5-second delay
  }

  // Add event listeners for mouse events
  partRect.addEventListener('mousedown', startDrag);
  document.addEventListener('mousemove', drag);
  document.addEventListener('mouseup', stopDrag);

  // Add event listeners for touch events
  partRect.addEventListener('touchstart', startDrag, { passive: false });
  document.addEventListener('touchmove', drag, { passive: false });
  document.addEventListener('touchend', stopDrag);
}

function showWireForDraggedPart(draggedPart, snappedPosition) {
  // Remove any existing temporary wire
  svgGrid.querySelectorAll('.temp-wire').forEach(wire => wire.remove());

  if (draggedPart.classList.contains('part-zumnet')) {
    // Show wire for ZUMNET part
    const zumnetParts = Array.from(svgGrid.querySelectorAll('.part-zumnet'));
    const index = zumnetParts.indexOf(draggedPart);

    if (index < zumnetParts.length - 1) {
      const nextPart = zumnetParts[index + 1];

      const part1X = snappedPosition.x;
      const part1Y = snappedPosition.y + parseFloat(draggedPart.getAttribute('height'));
      const part1Width = parseFloat(draggedPart.getAttribute('width'));

      const part2X = parseFloat(nextPart.getAttribute('x'));
      const part2Y = parseFloat(nextPart.getAttribute('y')) + parseFloat(nextPart.getAttribute('height'));
      const part2Width = parseFloat(nextPart.getAttribute('width'));

      // Check if parts are on the same rail
      const isSameRail = Math.abs(part1Y - part2Y) < 5; // Allow for small floating-point differences

      if (isSameRail) {
        // Wire on the same rail
        const wire = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        wire.setAttribute('d', `
          M ${part1X + 20} ${part1Y}
          V ${part1Y + 20}
          H ${part2X + 10}
          V ${part2Y}
        `);
        wire.setAttribute('stroke', '#6f42c1'); // Purple
        wire.setAttribute('stroke-width', '2');
        wire.setAttribute('fill', 'none');
        wire.setAttribute('class', 'wire-net temp-wire'); // Mark as temporary wire
        svgGrid.appendChild(wire);
      } else {
        // Wire between rails
        const railX = parseFloat(currentRails[0].rail.getAttribute('x'));
        const widthFromPartToRail = part1X + part1Width - railX; // Width from part to beginning of rail

        const wire = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        wire.setAttribute('d', `
          M ${part1X + 20} ${part1Y}
          V ${part1Y + 30}
          H ${railX - 40}
          V ${part2Y + 20}
          H ${part2X + 10}
          V ${part2Y}
        `);
        wire.setAttribute('stroke', '#6f42c1'); // Purple
        wire.setAttribute('stroke-width', '2');
        wire.setAttribute('fill', 'none');
        wire.setAttribute('class', 'wire-net temp-wire'); // Mark as temporary wire
        svgGrid.appendChild(wire);
      }
    }
  } else if (draggedPart.classList.contains('part-zumlink')) {
    // Show wire for ZUMLINK part
    const zumnetParts = Array.from(svgGrid.querySelectorAll('.part-zumnet'));
    const zumlinkParts = Array.from(svgGrid.querySelectorAll('.part-zumlink:not(.part-psu)')); // Exclude PSU

    // Find the ZUMNET part this ZUMLINK is connected to
    const zumnet = zumnetParts.find(zumnet => {
      const zumnetY = parseFloat(zumnet.getAttribute('y'));
      const zumnetX = parseFloat(zumnet.getAttribute('x'));
      return zumnetY === snappedPosition.y && zumnetX < snappedPosition.x;
    });

    if (zumnet) {
      const zumnetX = parseFloat(zumnet.getAttribute('x'));
      const zumnetY = parseFloat(zumnet.getAttribute('y')) + parseFloat(zumnet.getAttribute('height'));
      const zumnetWidth = parseFloat(zumnet.getAttribute('width'));

      const zumlinkX = snappedPosition.x;
      const zumlinkY = snappedPosition.y + parseFloat(draggedPart.getAttribute('height'));
      const zumlinkWidth = parseFloat(draggedPart.getAttribute('width'));

      // Wire from ZUMNET to the ZUMLINK
      const wire = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      wire.setAttribute('d', `
        M ${zumnetX + zumnetWidth - 10} ${zumnetY}
        V ${zumnetY + 30}
        H ${zumlinkX + 10}
        V ${zumlinkY}
      `);
      wire.setAttribute('stroke', '#fd7e14'); // Orange
      wire.setAttribute('stroke-width', '2');
      wire.setAttribute('fill', 'none');
      wire.setAttribute('class', 'wire-link temp-wire'); // Mark as temporary wire
      svgGrid.appendChild(wire);
    }
  }
}

function reconnectAllWires() {
  // Remove all temporary wires
  svgGrid.querySelectorAll('.temp-wire').forEach(wire => wire.remove());

  // Reconnect ZUMNET parts
  connectZumnetParts();

  // Reconnect ZUMLINK parts
  connectZumlinkParts();

  // Reconnect PSU parts
  connectPSUParts();
}

function updatePartText(partRect, snappedPosition) {
  const partNumber = partRect.nextElementSibling;
  if (partNumber && partNumber.tagName === 'text') {
    partNumber.setAttribute('x', snappedPosition.x + 5);
    partNumber.setAttribute('y', snappedPosition.y + 15);
  }

  const partNameText = partNumber.nextElementSibling;
  if (partNameText && partNameText.tagName === 'text') {
    partNameText.setAttribute('x', snappedPosition.x + 5);
    partNameText.setAttribute('y', snappedPosition.y + 30);
  }
}

function snapToRailsAndParts(newX, newY, partRect) {
  const partWidth = parseFloat(partRect.getAttribute('width'));
  const partHeight = parseFloat(partRect.getAttribute('height'));
  const railX = parseFloat(currentRails[0].rail.getAttribute('x'));
  const railY = parseFloat(currentRails[0].rail.getAttribute('y'));
  const railWidth = 324; // Width of the rail
  const railHeight = 18; // Height of the rail

  // Snap to rails
  let snappedX = newX;
  let snappedY = newY;

  // Snap to the nearest rail
  for (const rail of currentRails) {
    const railTop = parseFloat(rail.rail.getAttribute('y'));
    const railBottom = railTop + railHeight;

    // Check if the bottom of the part is near the top of the rail
    if (newY + partHeight >= railTop - 5 && newY + partHeight <= railTop + 5) {
      snappedY = railTop - partHeight; // Align the bottom of the part to the top of the rail
      break;
    }
  }

  // Snap to the nearest part on the left or right
  let nearestPart = null;
  let minDistance = Infinity;

  for (const rail of currentRails) {
    for (const part of rail.parts) {
      if (part === partRect) continue; // Skip the part being dragged

      const partX = parseFloat(part.getAttribute('x'));
      const partY = parseFloat(part.getAttribute('y'));
      const partWidthOther = parseFloat(part.getAttribute('width'));
      const partHeightOther = parseFloat(part.getAttribute('height'));

      // Check if the part is on the left or right of the dragged part
      const isLeft = partX + partWidthOther <= newX;
      const isRight = partX >= newX + partWidth;

      if (isLeft || isRight) {
        // Calculate the distance between the parts
        const distance = Math.abs(newX - (partX + partWidthOther));

        // Check if the tops are aligned (within 5px)
        const isTopAligned = Math.abs(partY - newY) < 5;

        if (isTopAligned && distance < minDistance) {
          nearestPart = part;
          minDistance = distance;
        }
      }
    }
  }

  // Snap to the nearest part
  if (nearestPart) {
    const partX = parseFloat(nearestPart.getAttribute('x'));
    const partY = parseFloat(nearestPart.getAttribute('y'));
    const partWidthOther = parseFloat(nearestPart.getAttribute('width'));

    // Align the tops of the parts
    snappedY = partY;

    // Snap to the left or right of the nearest part
    if (newX < partX) {
      snappedX = partX - partWidth; // Snap to the left
    } else {
      snappedX = partX + partWidthOther; // Snap to the right
    }
  }

  // Prevent overlapping other parts
  for (const rail of currentRails) {
    for (const part of rail.parts) {
      if (part === partRect) continue; // Skip the part being dragged

      const partX = parseFloat(part.getAttribute('x'));
      const partY = parseFloat(part.getAttribute('y'));
      const partWidthOther = parseFloat(part.getAttribute('width'));
      const partHeightOther = parseFloat(part.getAttribute('height'));

      if (
        snappedX < partX + partWidthOther &&
        snappedX + partWidth > partX &&
        snappedY < partY + partHeightOther &&
        snappedY + partHeight > partY
      ) {
        // Overlap detected, revert to previous position
        snappedX = parseFloat(partRect.getAttribute('x'));
        snappedY = parseFloat(partRect.getAttribute('y'));
        break;
      }
    }
  }

  return { x: snappedX, y: snappedY };
}

// Modal functionality
const modal = document.getElementById('part-modal');
const closeModal = document.querySelector('.close');
const partForm = document.getElementById('part-form');

function openModal(partRect, partNumberText) {
  const partId = partRect.getAttribute('data-part-id');
  const partData = partDataMap.get(partId) || {};

  // Set the Space Number to the current part number
  document.getElementById('space-number').value = partNumberText.textContent || '';
  document.getElementById('space-name').value = partData.spaceName || '';
  document.getElementById('zone').value = partData.zone || '';
  document.getElementById('voltage').value = partData.voltage || '120';
  document.getElementById('lighting-load').value = partData.lightingLoad || '';
  document.getElementById('device-mA').value = partData.deviceMA || '';

  modal.style.display = 'block';

  // Save the partId and partNumberText in the form for reference
  partForm.setAttribute('data-part-id', partId);
  partForm.setAttribute('data-part-number', partNumberText.textContent);
}

partForm.addEventListener('submit', (event) => {
  event.preventDefault();

  const partId = partForm.getAttribute('data-part-id');
  const oldPartNumber = partForm.getAttribute('data-part-number');
  const newPartNumber = document.getElementById('space-number').value;

  const partData = {
    spaceNumber: newPartNumber,
    spaceName: document.getElementById('space-name').value,
    zone: document.getElementById('zone').value,
    voltage: document.getElementById('voltage').value,
    lightingLoad: document.getElementById('lighting-load').value,
    deviceMA: document.getElementById('device-mA').value,
  };

  // Update the part number text
  const partNumberText = document.querySelector(`[data-part-id="${partId}"] + text`);
  partNumberText.textContent = newPartNumber;

  // Update the ZUMNET counter if the part is a ZUMNET part
  if (partNumberText.textContent && partNumberText.textContent !== oldPartNumber) {
    const partRect = document.querySelector(`[data-part-id="${partId}"]`);
    const partName = partRect.getAttribute('data-part-name'); // Assuming you add this attribute when creating the part

    if (partName && partName.startsWith('ZUMNET')) {
      zumnetCounter = Math.max(zumnetCounter, parseInt(newPartNumber) + 1);
      lastZumnetNumber = parseInt(newPartNumber);
    }
  }

  // Save the data
  partDataMap.set(partId, partData);
  closeModalFunc();
});

function closeModalFunc() {
  modal.style.display = 'none';
}

closeModal.addEventListener('click', closeModalFunc);

window.addEventListener('click', (event) => {
  if (event.target === modal) {
    closeModalFunc();
  }
});

partForm.addEventListener('submit', (event) => {
  event.preventDefault();

  const partId = partForm.getAttribute('data-part-id');
  const partNumberText = partForm.getAttribute('data-part-number');
  const partData = {
    spaceNumber: document.getElementById('space-number').value,
    spaceName: document.getElementById('space-name').value,
    zone: document.getElementById('zone').value,
    voltage: document.getElementById('voltage').value,
    lightingLoad: document.getElementById('lighting-load').value,
    deviceMA: document.getElementById('device-mA').value,
  };

  // Update the part number text
  partNumberText.textContent = partData.spaceNumber;

  // Save the data
  partDataMap.set(partId, partData);
  closeModalFunc();
});

function printPDF() {
  const grid = document.getElementById('grid');
  const svgGrid = document.getElementById('svg-grid');

  // Function to hide/show parts and add/remove white squares
  function toggleParts(partClass, show) {
    const parts = svgGrid.querySelectorAll(`.${partClass}`);
    parts.forEach(part => {
      if (show) {
        // Show the part
        part.style.display = 'inline';

        // Remove the white square if it exists
        const whiteSquare = part.nextElementSibling;
        if (whiteSquare && whiteSquare.classList.contains('white-square')) {
          whiteSquare.remove();
        }
      } else {
        // Hide the part
        part.style.display = 'none';

        // Add a white square to cover the part and its text
        const partX = parseFloat(part.getAttribute('x'));
        const partY = parseFloat(part.getAttribute('y'));
        const partWidth = parseFloat(part.getAttribute('width'));
        const partHeight = parseFloat(part.getAttribute('height'));

        const whiteSquare = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        whiteSquare.setAttribute('x', partX);
        whiteSquare.setAttribute('y', partY);
        whiteSquare.setAttribute('width', partWidth);
        whiteSquare.setAttribute('height', partHeight);
        whiteSquare.setAttribute('fill', 'white');
        whiteSquare.setAttribute('stroke', 'black'); // Optional: Add a border for visibility
        whiteSquare.setAttribute('stroke-width', '1');
        whiteSquare.classList.add('white-square');

        // Insert the white square after the part
        part.parentNode.insertBefore(whiteSquare, part.nextSibling);
      }
    });
  }

  // Function to hide/show wires based on their class and increase stroke width for printing
  function toggleWires(wireClass, show) {
    const wires = svgGrid.querySelectorAll(`.${wireClass}`);
    wires.forEach(wire => {
      wire.style.display = show ? 'inline' : 'none';
      // Increase stroke width for printing
      if (show) {
        wire.setAttribute('stroke-width', '4'); // Increase stroke width for printing
      } else {
        wire.setAttribute('stroke-width', '2'); // Reset to default stroke width
      }
    });
  }

  // Function to hide/show PSU wires based on the PSU index
  function togglePSUWires(psuIndex, show) {
    const psuWires = svgGrid.querySelectorAll('.wire-psu');
    psuWires.forEach((wire, index) => {
      // Show only the wires for the current PSU
      if (index >= psuIndex * 4 && index < (psuIndex + 1) * 4) {
        wire.style.display = show ? 'inline' : 'none';
        // Increase stroke width for printing
        if (show) {
          wire.setAttribute('stroke-width', '4'); // Increase stroke width for printing
        } else {
          wire.setAttribute('stroke-width', '2'); // Reset to default stroke width
        }
      } else {
        // Hide wires for all other PSUs
        wire.style.display = 'none';
      }
    });
  }

  // Create a new PDF instance
  const pdf = new jspdf.jsPDF({
    orientation: 'portrait', // Use portrait orientation for 11x17
    unit: 'mm',
    format: [432, 279], // 11x17 inches in mm (width x height)
  });

  // Calculate the dimensions of the panel
  const panelWidth = grid.offsetWidth; // Width of the grid in pixels
  const panelHeight = grid.offsetHeight; // Height of the grid in pixels

  // 11x17 page dimensions in mm (portrait)
  const pageWidth = 279; // 11 inches in mm
  const pageHeight = 432; // 17 inches in mm

  // Calculate the scaling factor to fit the panel on one page
  const scaleX = pageWidth / panelWidth; // Scaling factor for width
  const scaleY = pageHeight / panelHeight; // Scaling factor for height
  const scale = Math.min(scaleX, scaleY); // Use the smaller scaling factor to fit the entire panel

  // Calculate the scaled dimensions of the panel
  const scaledWidth = panelWidth * scale;
  const scaledHeight = panelHeight * scale;

  // Center the panel on the page
  const offsetX = (pageWidth - scaledWidth) / 2;
  const offsetY = (pageHeight - scaledHeight) / 2;

  // Capture the first page (only ZUMNET parts and purple wires)
  toggleParts('part-zumnet', true); // Show ZUMNET parts
  toggleParts('part-zumlink', false); // Hide ZUMLINK parts (replace with white squares)
  toggleParts('part-psu', false); // Hide PSU parts (replace with white squares)
  toggleWires('wire-net', true); // Show purple wires
  toggleWires('wire-link', false); // Hide orange wires
  toggleWires('wire-psu', false); // Hide PSU wires
  html2canvas(grid, {
    scale: 2, // Increase scale for better quality
    logging: true, // Enable logging for debugging
    useCORS: true, // Enable CORS for external resources (if any)
  }).then(canvas1 => {
    const imgData1 = canvas1.toDataURL('image/png'); // Convert canvas to image data URL

    // Add the first page (only ZUMNET parts and purple wires)
    pdf.addImage(imgData1, 'PNG', offsetX, offsetY, scaledWidth, scaledHeight);

    // Capture the second page (ZUMNET and ZUMLINK parts, orange wires)
    toggleParts('part-zumnet', true); // Show ZUMNET parts
    toggleParts('part-zumlink', true); // Show ZUMLINK parts
    toggleParts('part-psu', false); // Hide PSU parts (replace with white squares)
    toggleWires('wire-net', false); // Hide purple wires
    toggleWires('wire-link', true); // Show orange wires
    toggleWires('wire-psu', false); // Hide PSU wires
    html2canvas(grid, {
      scale: 2, // Increase scale for better quality
      logging: true, // Enable logging for debugging
      useCORS: true, // Enable CORS for external resources (if any)
    }).then(canvas2 => {
      const imgData2 = canvas2.toDataURL('image/png'); // Convert canvas to image data URL

      // Add the second page (ZUMNET and ZUMLINK parts, orange wires)
      pdf.addPage();
      pdf.addImage(imgData2, 'PNG', offsetX, offsetY, scaledWidth, scaledHeight);

      // Capture additional pages for each PSU and its wiring
      const psuParts = Array.from(svgGrid.querySelectorAll('.part-psu'));
      psuParts.forEach((psu, psuIndex) => {
        // Hide all parts first
        toggleParts('part-zumnet', false); // Hide ZUMNET parts (replace with white squares)
        toggleParts('part-zumlink', false); // Hide ZUMLINK parts (replace with white squares)
        toggleParts('part-psu', false); // Hide all PSU parts (replace with white squares)

        // Show only the current PSU and its connected ZUMNET parts
        toggleParts('part-psu', true); // Show the current PSU
        toggleParts('part-zumnet', true); // Show ZUMNET parts
        toggleWires('wire-net', false); // Hide purple wires
        toggleWires('wire-link', false); // Hide orange wires
        togglePSUWires(psuIndex, true); // Show wires for the current PSU

        // Capture the canvas for the current PSU
        html2canvas(grid, {
          scale: 2, // Increase scale for better quality
          logging: true, // Enable logging for debugging
          useCORS: true, // Enable CORS for external resources (if any)
        }).then(canvas => {
          const imgData = canvas.toDataURL('image/png'); // Convert canvas to image data URL

          // Add a new page for the current PSU
          pdf.addPage();
          pdf.addImage(imgData, 'PNG', offsetX, offsetY, scaledWidth, scaledHeight);

          // If this is the last PSU, save the PDF
          if (psuIndex === psuParts.length - 1) {
            pdf.save('panel-and-wiring-11x17.pdf');

            // Reset part visibility and remove white squares
            toggleParts('part-zumnet', true); // Show ZUMNET parts
            toggleParts('part-zumlink', true); // Show ZUMLINK parts
            toggleParts('part-psu', true); // Show PSU parts
            toggleWires('wire-net', true); // Show purple wires
            toggleWires('wire-link', true); // Show orange wires
            toggleWires('wire-psu', true); // Show PSU wires

            // Reset wire stroke width to default
            const allWires = svgGrid.querySelectorAll('.wire');
            allWires.forEach(wire => {
              wire.setAttribute('stroke-width', '2'); // Reset to default stroke width
            });
          }
        });
      });
    });
  });
}

function importJSON() {
  // Create a file input element
  const fileInput = document.createElement('input');
  fileInput.type = 'file';
  fileInput.accept = '.json';
  fileInput.style.display = 'none';

  // Add event listener for file selection
  fileInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const jsonData = JSON.parse(e.target.result);
        buildPanelFromJSON(jsonData);
      };
      reader.readAsText(file);
    }
  });

  // Trigger the file input dialog
  fileInput.click();
}

function buildPanelFromJSON(jsonData) {
  // Clear the existing panel
  clearPanel();

  // Iterate through each space in the JSON
  jsonData.spaces.forEach((space) => {
    const spaceName = space.name;

    // Add ZUMNET parts first if they exist
    space.zones.forEach((zone) => {
      if (zone.type.startsWith('ZUMNET') && zone.value > 0) {
        for (let i = 0; i < zone.value; i++) {
          addPart(zone.type);
        }
      }
    });

    // Add ZUMLINK parts next
    space.zones.forEach((zone) => {
      if (zone.type.startsWith('ZUMLINK') && zone.value > 0) {
        for (let i = 0; i < zone.value; i++) {
          addPart(zone.type);
        }
      }
    });

    // Add LV parts based on the "lv" configuration
    if (space.lv) {
      const lvZumlinkQty = space.lv.zumlink;
      const lvZumnetQty = space.lv.zumnet;

      for (let i = 0; i < lvZumlinkQty; i++) {
        addPart('ZUMLINK-DIN-16A-LV');
      }

      for (let i = 0; i < lvZumnetQty; i++) {
        addPart('ZUMNET-DIN-16A-LV');
      }
    }
  });

  // Auto-wire the panel after adding all parts
  connectZumnetParts();
}
  </script>
</body>
</html>
